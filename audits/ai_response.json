{
  "commit_message": "feat: add client-side pagination helper and UI controls on product list; add tests",
  "files": [
    {
      "path": "lib/pagination.js",
      "content": "function paginate(items = [], page = 1, pageSize = 20) {\n  const total = Array.isArray(items) ? items.length : 0;\n  const safePageSize = Math.max(1, parseInt(pageSize, 10) || 20);\n  const totalPages = Math.max(1, Math.ceil(total / safePageSize));\n  const safePage = Math.max(1, Math.min(parseInt(page, 10) || 1, totalPages));\n\n  const start = (safePage - 1) * safePageSize;\n  const end = start + safePageSize;\n  const pageItems = Array.isArray(items) ? items.slice(start, end) : [];\n\n  return {\n    pageItems,\n    total,\n    page: safePage,\n    pageSize: safePageSize,\n    totalPages,\n  };\n}\n\nmodule.exports = paginate;\n"
    },
    {
      "path": "pages/index.js",
      "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { useRouter } from 'next/router';\nimport ProductList from '../components/ProductList';\nimport ExportCsvLink from '../components/ExportCsvLink';\nimport StockFilterToggle from '../components/StockFilterToggle';\nimport { addTimestampsToProducts } from '../lib/ensureTimestamps';\nimport { addImagesToProducts } from '../lib/ensureProductImages';\nimport paginate from '../lib/pagination';\n\nconst Home = () => {\n  const router = useRouter();\n  const [products, setProducts] = useState([]);\n  const [query, setQuery] = useState('');\n  const [allTags, setAllTags] = useState([]);\n  const [selectedTags, setSelectedTags] = useState([]);\n  const [inStockOnly, setInStockOnly] = useState(false);\n  const [page, setPage] = useState(1);\n  const [pageSize] = useState(20);\n\n  // ref for the search input so we can focus it via keyboard shortcut\n  const searchInputRef = useRef(null);\n\n  const initializedFromUrl = useRef(false);\n\n  // Initialize filter state from URL on first render\n  useEffect(() => {\n    if (initializedFromUrl.current) return;\n    const q = router?.query || {};\n    if (typeof q.search === 'string') setQuery(q.search);\n    if (typeof q.tags === 'string' && q.tags.trim()) {\n      setSelectedTags(q.tags.split(',').map((t) => decodeURIComponent(t)));\n    }\n    if (q.inStock === '1' || q.inStock === 'true') setInStockOnly(true);\n    if (q.page) {\n      const p = parseInt(q.page, 10);\n      if (!Number.isNaN(p) && p > 0) setPage(p);\n    }\n    initializedFromUrl.current = true;\n  }, [router?.query]);\n\n  // Keep URL in sync with filters (for shareable links and CSV export)\n  useEffect(() => {\n    // Avoid pushing identical queries repeatedly\n    const nextQuery = {};\n    if (query) nextQuery.search = query;\n    if (selectedTags.length) nextQuery.tags = selectedTags.join(',');\n    if (inStockOnly) nextQuery.inStock = '1';\n    if (page && page > 1) nextQuery.page = String(page);\n\n    const current = router?.query || {};\n    const same =\n      current.search === nextQuery.search &&\n      (current.tags || '') === (nextQuery.tags || '') &&\n      (current.inStock || '') === (nextQuery.inStock || '') &&\n      ((current.page || '') === (nextQuery.page || ''));\n\n    if (!same) {\n      router.replace({ pathname: router.pathname, query: nextQuery }, undefined, { shallow: true });\n    }\n  }, [query, selectedTags, inStockOnly, page]);\n\n  // reset to first page when main filters change\n  useEffect(() => {\n    setPage(1);\n  }, [query, selectedTags, inStockOnly]);\n\n  useEffect(() => {\n    let cancelled = false;\n    const loadTags = async () => {\n      try {\n        const res = await fetch('/api/tags');\n        const data = await res.json();\n        if (!cancelled) setAllTags(Array.isArray(data) ? data : []);\n      } catch (e) {\n        if (!cancelled) setAllTags([]);\n      }\n    };\n    loadTags();\n    return () => {\n      cancelled = true;\n    };\n  }, []);\n\n  useEffect(() => {\n    let active = true;\n    const controller = new AbortController();\n\n    const fetchProducts = async () => {\n      const params = [];\n      if (query) params.push(`search=${encodeURIComponent(query)}`);\n      if (selectedTags.length > 0) params.push(`tags=${selectedTags.map(encodeURIComponent).join(',')}`);\n      if (inStockOnly) params.push('inStock=1');\n      const qs = params.length ? `?${params.join('&')}` : '';\n      const res = await fetch(`/api/products${qs}`, { signal: controller.signal });\n      const data = await res.json();\n      // augment products with deterministic timestamps for richer UI and export\n      const augmented = addTimestampsToProducts(Array.isArray(data) ? data : []);\n      // also ensure each product has a deterministic placeholder image\n      const withImages = addImagesToProducts(augmented);\n      if (active) setProducts(withImages);\n    };\n\n    const t = setTimeout(fetchProducts, 250);\n\n    return () => {\n      active = false;\n      controller.abort();\n      clearTimeout(t);\n    };\n  }, [query, selectedTags, inStockOnly]);\n\n  // Keyboard shortcut: press '/' to focus the search input\n  useEffect(() => {\n    const handler = (e) => {\n      // only trigger on the '/' key, ignore when focus is already in an input/textarea\n      if (e.key === '/') {\n        const active = document.activeElement;\n        const tag = active && active.tagName && active.tagName.toLowerCase();\n        if (tag !== 'input' && tag !== 'textarea') {\n          e.preventDefault();\n          if (searchInputRef.current) searchInputRef.current.focus();\n        }\n      }\n    };\n    window.addEventListener('keydown', handler);\n    return () => window.removeEventListener('keydown', handler);\n  }, []);\n\n  const toggleTag = (tag) => {\n    setSelectedTags((prev) => {\n      if (prev.includes(tag)) return prev.filter((t) => t !== tag);\n      return [...prev, tag];\n    });\n  };\n\n  const clearAllFilters = () => {\n    setQuery('');\n    setSelectedTags([]);\n    setInStockOnly(false);\n    setPage(1);\n  };\n\n  const anyFilterActive = query || selectedTags.length > 0 || inStockOnly;\n\n  const { pageItems: displayedProducts, total, totalPages } = paginate(products, page, pageSize);\n\n  return (\n    <div style={{ maxWidth: 900, margin: '0 auto', padding: '1rem' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '1rem', flexWrap: 'wrap' }}>\n        <input\n          ref={searchInputRef}\n          type=\"search\"\n          placeholder=\"Search products by name, SKU or description...\"\n          value={query}\n          onChange={(e) => setQuery(e.target.value)}\n          style={{ flex: 1, minWidth: 260, padding: '0.5rem 0.75rem', border: '1px solid #ddd', borderRadius: 6 }}\n          aria-label=\"Search products\"\n        />\n        <StockFilterToggle checked={inStockOnly} onChange={setInStockOnly} />\n        <span style={{ color: '#666', fontSize: 12 }}>\n          {total || 0} result{(total || 0) === 1 ? '' : 's'}\n        </span>\n        <ExportCsvLink style={{ fontSize: 12 }} />\n\n        {/* Render a compact clear-all action when any of the main filters are active */}\n        {anyFilterActive && (\n          <button\n            onClick={clearAllFilters}\n            aria-label=\"Clear filters\"\n            style={{ padding: '0.25rem 0.5rem', borderRadius: 6, border: '1px solid #ddd', background: '#fafafa', cursor: 'pointer', fontSize: 12 }}\n          >\n            Clear filters\n          </button>\n        )}\n      </div>\n\n      {allTags.length > 0 && (\n        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem', marginBottom: '1rem' }}>\n          {allTags.map((tag) => {\n            const active = selectedTags.includes(tag);\n            return (\n              <button\n                key={tag}\n                onClick={() => toggleTag(tag)}\n                aria-pressed={active}\n                style={{\n                  padding: '0.25rem 0.5rem',\n                  borderRadius: 999,\n                  border: '1px solid ' + (active ? '#0b64d8' : '#ddd'),\n                  background: active ? '#e7f1ff' : 'white',\n                  color: active ? '#0b64d8' : '#333',\n                  cursor: 'pointer',\n                  fontSize: 12,\n                }}\n              >\n                {tag}\n              </button>\n            );\n          })}\n          {selectedTags.length > 0 && (\n            <button\n              onClick={() => setSelectedTags([])}\n              style={{\n                marginLeft: 'auto',\n                padding: '0.25rem 0.5rem',\n                borderRadius: 6,\n                border: '1px solid #ddd',\n                background: '#fafafa',\n                cursor: 'pointer',\n                fontSize: 12,\n              }}\n              aria-label=\"Clear selected tags\"\n            >\n              Clear tags\n            </button>\n          )}\n        </div>\n      )}\n\n      <ProductList products={displayedProducts} />\n\n      {/* Pagination controls (client-side) */}\n      {total > pageSize && (\n        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginTop: '1rem' }}>\n          <button\n            onClick={() => setPage((p) => Math.max(1, p - 1))}\n            disabled={page <= 1}\n            aria-label=\"Previous page\"\n            style={{ padding: '0.4rem 0.6rem', borderRadius: 6, border: '1px solid #ddd', background: '#fff', cursor: page <= 1 ? 'not-allowed' : 'pointer' }}\n          >\n            Prev\n          </button>\n          <span style={{ color: '#666', fontSize: 13 }}>\n            Page {page} of {totalPages}\n          </span>\n          <button\n            onClick={() => setPage((p) => Math.min(totalPages, p + 1))}\n            disabled={page >= totalPages}\n            aria-label=\"Next page\"\n            style={{ padding: '0.4rem 0.6rem', borderRadius: 6, border: '1px solid #ddd', background: '#fff', cursor: page >= totalPages ? 'not-allowed' : 'pointer' }}\n          >\n            Next\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Home;\n"
    },
    {
      "path": "tests/pagination.test.js",
      "content": "const paginate = require('../lib/pagination');\n\ndescribe('paginate()', () => {\n  const items = Array.from({ length: 55 }, (_, i) => ({ id: i + 1 }));\n\n  test('returns correct page items and metadata for first page', () => {\n    const { pageItems, total, page, pageSize, totalPages } = paginate(items, 1, 20);\n    expect(total).toBe(55);\n    expect(page).toBe(1);\n    expect(pageSize).toBe(20);\n    expect(totalPages).toBe(3);\n    expect(pageItems.length).toBe(20);\n    expect(pageItems[0].id).toBe(1);\n    expect(pageItems[pageItems.length - 1].id).toBe(20);\n  });\n\n  test('returns last page with remainder items', () => {\n    const { pageItems, page, totalPages } = paginate(items, 3, 20);\n    expect(page).toBe(3);\n    expect(totalPages).toBe(3);\n    expect(pageItems.length).toBe(15);\n    expect(pageItems[0].id).toBe(41);\n    expect(pageItems[pageItems.length - 1].id).toBe(55);\n  });\n\n  test('handles page out of range by clamping', () => {\n    const outLow = paginate(items, -5, 10);\n    expect(outLow.page).toBe(1);\n    const outHigh = paginate(items, 999, 10);\n    expect(outHigh.page).toBe(outHigh.totalPages);\n  });\n\n  test('handles non-array gracefully', () => {\n    const result = paginate(null, 1, 10);\n    expect(result.total).toBe(0);\n    expect(result.pageItems).toEqual([]);\n    expect(result.totalPages).toBe(1);\n  });\n});\n"
    }
  ]
}