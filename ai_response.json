{
  "files": [
    {
      "path": "pages/admin/attribute-groups.js",
      "content": "import React, { useEffect, useMemo, useState } from 'react';\n\nconst { normalizeAttributes, validateAttributeGroup, upsertGroup } = require('../../lib/attributeGroups');\n\nconst STORAGE_KEY = 'pim:attributeGroups';\n\nfunction safeLoad() {\n  if (typeof window === 'undefined') return [];\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return [];\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) return [];\n    return parsed;\n  } catch (e) {\n    console.warn('Failed to load attribute groups from localStorage', e);\n    return [];\n  }\n}\n\nfunction safeSave(groups) {\n  if (typeof window === 'undefined') return;\n  try {\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(groups));\n  } catch (e) {\n    console.warn('Failed to save attribute groups to localStorage', e);\n  }\n}\n\nexport default function AttributeGroupsAdminPage() {\n  const [groups, setGroups] = useState([]);\n  const [name, setName] = useState('');\n  const [attrsInput, setAttrsInput] = useState('');\n  const [errors, setErrors] = useState([]);\n  const [editingId, setEditingId] = useState(null);\n\n  useEffect(() => {\n    setGroups(safeLoad());\n  }, []);\n\n  useEffect(() => {\n    // Persist whenever groups change (client only)\n    safeSave(groups);\n  }, [groups]);\n\n  const previewAttributes = useMemo(() => normalizeAttributes(attrsInput), [attrsInput]);\n\n  function resetForm() {\n    setName('');\n    setAttrsInput('');\n    setErrors([]);\n    setEditingId(null);\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    const trimmedName = (name || '').trim();\n    const attrs = normalizeAttributes(attrsInput);\n\n    const base = editingId\n      ? groups.find((g) => g.id === editingId) || {}\n      : {};\n\n    const group = {\n      id: editingId || String(Date.now()),\n      name: trimmedName,\n      attributes: attrs,\n      createdAt: base.createdAt || new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n\n    const errs = validateAttributeGroup(\n      group,\n      groups.filter((g) => g.id !== editingId)\n    );\n\n    if (errs.length) {\n      setErrors(errs);\n      return;\n    }\n\n    const next = upsertGroup(groups, group);\n    setGroups(next);\n    resetForm();\n  }\n\n  function handleEdit(g) {\n    setEditingId(g.id);\n    setName(g.name);\n    setAttrsInput(g.attributes.map((a) => a.name).join(', '));\n    setErrors([]);\n  }\n\n  function handleDelete(id) {\n    if (typeof window !== 'undefined' && !window.confirm('Delete this attribute group?')) return;\n    const next = groups.filter((g) => g.id !== id);\n    setGroups(next);\n  }\n\n  const sortedGroups = useMemo(\n    () => [...groups].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)),\n    [groups]\n  );\n\n  return (\n    <div style={styles.page}>\n      <div style={styles.header}>\n        <h1 style={{ margin: 0 }}>Attribute Groups</h1>\n        <p style={{ color: '#666', marginTop: 6 }}>Define reusable attribute groups to enrich your products (e.g., Dimensions, Materials, SEO).</p>\n      </div>\n\n      <div style={styles.layout}>\n        <section style={styles.card}>\n          <h2 style={styles.cardTitle}>{editingId ? 'Edit Group' : 'Create Group'}</h2>\n          {errors.length > 0 && (\n            <div style={styles.errorBox}>\n              {errors.map((err, i) => (\n                <div key={i}>• {err}</div>\n              ))}\n            </div>\n          )}\n          <form onSubmit={handleSubmit}>\n            <label style={styles.label}>\n              Group name\n              <input\n                style={styles.input}\n                type=\"text\"\n                placeholder=\"e.g., Dimensions\"\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n              />\n            </label>\n\n            <label style={styles.label}>\n              Attributes (comma, semicolon or newline separated)\n              <textarea\n                style={{ ...styles.input, minHeight: 86 }}\n                placeholder={\"e.g.,\\nWidth, Height, Depth\"}\n                value={attrsInput}\n                onChange={(e) => setAttrsInput(e.target.value)}\n              />\n            </label>\n\n            <div style={{ marginTop: 8, color: '#666', fontSize: 13 }}>\n              Preview: {previewAttributes.length} attribute{previewAttributes.length === 1 ? '' : 's'}\n              {previewAttributes.length > 0 && (\n                <div style={{ marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>\n                  {previewAttributes.map((a) => (\n                    <span key={a.name} style={styles.chip}>{a.name}</span>\n                  ))}\n                </div>\n              )}\n            </div>\n\n            <div style={{ display: 'flex', gap: 8, marginTop: 16 }}>\n              <button style={styles.primaryBtn} type=\"submit\">{editingId ? 'Save Changes' : 'Create Group'}</button>\n              {editingId && (\n                <button type=\"button\" style={styles.secondaryBtn} onClick={resetForm}>Cancel</button>\n              )}\n            </div>\n          </form>\n        </section>\n\n        <section style={styles.card}>\n          <h2 style={styles.cardTitle}>Existing Groups</h2>\n          {sortedGroups.length === 0 ? (\n            <div style={{ color: '#666' }}>No attribute groups yet. Create your first one on the left.</div>\n          ) : (\n            <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>\n              {sortedGroups.map((g) => (\n                <li key={g.id} style={styles.listItem}>\n                  <div style={{ flex: 1 }}>\n                    <div style={{ fontWeight: 600 }}>{g.name}</div>\n                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: 6, marginTop: 6 }}>\n                      {g.attributes.map((a) => (\n                        <span key={a.name} style={styles.chipSmall}>{a.name}</span>\n                      ))}\n                    </div>\n                    <div style={{ color: '#888', fontSize: 12, marginTop: 6 }}>\n                      {g.attributes.length} attribute{g.attributes.length === 1 ? '' : 's'} • Created {new Date(g.createdAt).toLocaleString()}\n                    </div>\n                  </div>\n                  <div style={{ display: 'flex', gap: 8 }}>\n                    <button style={styles.smallBtn} onClick={() => handleEdit(g)}>Edit</button>\n                    <button style={styles.smallDangerBtn} onClick={() => handleDelete(g.id)}>Delete</button>\n                  </div>\n                </li>\n              ))}\n            </ul>\n          )}\n        </section>\n      </div>\n\n      <footer style={{ color: '#888', fontSize: 12, marginTop: 24 }}>\n        Data is stored locally in your browser for this prototype. Integrate with your backend to share across users.\n      </footer>\n    </div>\n  );\n}\n\nconst styles = {\n  page: {\n    maxWidth: 1000,\n    margin: '24px auto',\n    padding: '0 16px',\n    fontFamily: 'ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial',\n  },\n  header: {\n    marginBottom: 16,\n  },\n  layout: {\n    display: 'grid',\n    gridTemplateColumns: '1fr 1fr',\n    gap: 16,\n  },\n  card: {\n    border: '1px solid #e5e7eb',\n    borderRadius: 8,\n    padding: 16,\n    background: 'white',\n  },\n  cardTitle: {\n    marginTop: 0,\n    marginBottom: 12,\n    fontSize: 18,\n  },\n  label: {\n    display: 'block',\n    fontWeight: 600,\n    marginTop: 8,\n    marginBottom: 6,\n  },\n  input: {\n    display: 'block',\n    width: '100%',\n    padding: '8px 10px',\n    border: '1px solid #d1d5db',\n    borderRadius: 6,\n    fontSize: 14,\n    outline: 'none',\n  },\n  primaryBtn: {\n    background: '#111827',\n    color: 'white',\n    border: '1px solid #111827',\n    borderRadius: 6,\n    padding: '8px 12px',\n    cursor: 'pointer',\n  },\n  secondaryBtn: {\n    background: 'white',\n    color: '#111827',\n    border: '1px solid #d1d5db',\n    borderRadius: 6,\n    padding: '8px 12px',\n    cursor: 'pointer',\n  },\n  smallBtn: {\n    background: 'white',\n    color: '#111827',\n    border: '1px solid #d1d5db',\n    borderRadius: 6,\n    padding: '6px 10px',\n    cursor: 'pointer',\n    fontSize: 13,\n  },\n  smallDangerBtn: {\n    background: '#fee2e2',\n    color: '#991b1b',\n    border: '1px solid #fecaca',\n    borderRadius: 6,\n    padding: '6px 10px',\n    cursor: 'pointer',\n    fontSize: 13,\n  },\n  errorBox: {\n    background: '#fef2f2',\n    border: '1px solid #fecaca',\n    color: '#991b1b',\n    borderRadius: 6,\n    padding: 10,\n    marginBottom: 10,\n    fontSize: 14,\n  },\n  listItem: {\n    display: 'flex',\n    gap: 12,\n    alignItems: 'flex-start',\n    border: '1px solid #f3f4f6',\n    borderRadius: 8,\n    padding: 12,\n    marginBottom: 10,\n  },\n  chip: {\n    background: '#eef2ff',\n    color: '#3730a3',\n    padding: '4px 8px',\n    borderRadius: 999,\n    fontSize: 12,\n  },\n  chipSmall: {\n    background: '#f3f4f6',\n    color: '#374151',\n    padding: '3px 8px',\n    borderRadius: 999,\n    fontSize: 12,\n  },\n};\n"
    },
    {
      "path": "lib/attributeGroups.js",
      "content": "function toArray(v) {\n  if (v == null) return [];\n  return Array.isArray(v) ? v : [v];\n}\n\nfunction normalizeAttributes(input) {\n  // Accept: string (comma/semicolon/newline separated), array of strings, or array of {name}\n  const parts = [];\n  for (const v of toArray(input)) {\n    if (typeof v === 'string') {\n      const split = v.split(/[;,\\n]/g).map((s) => s.trim()).filter(Boolean);\n      parts.push(...split);\n    } else if (v && typeof v === 'object') {\n      if (typeof v.name === 'string' && v.name.trim()) parts.push(v.name.trim());\n    }\n  }\n\n  const seen = new Set();\n  const out = [];\n  for (const name of parts) {\n    const key = name.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push({ name });\n  }\n  return out;\n}\n\nfunction validateAttributeGroup(group, existing = []) {\n  const errs = [];\n  const name = (group && group.name ? String(group.name) : '').trim();\n  if (!name) errs.push('Group name is required');\n\n  const attrs = Array.isArray(group && group.attributes) ? group.attributes : [];\n  if (attrs.length === 0) errs.push('At least one attribute is required');\n\n  // Uniqueness across existing (case-insensitive)\n  const lower = name.toLowerCase();\n  const conflict = existing.find((g) => (g.name || '').toLowerCase() === lower);\n  if (name && conflict) errs.push('A group with this name already exists');\n\n  // Ensure attribute names are unique after normalization\n  const names = attrs.map((a) => (a.name || '').trim()).filter(Boolean);\n  const uniq = new Set(names.map((n) => n.toLowerCase()));\n  if (names.length !== uniq.size) errs.push('Attribute names must be unique');\n\n  return errs;\n}\n\nfunction upsertGroup(groups, group) {\n  const list = Array.isArray(groups) ? groups.slice() : [];\n  const idx = list.findIndex((g) => g.id === group.id);\n  if (idx >= 0) {\n    list[idx] = { ...list[idx], ...group };\n  } else {\n    list.unshift(group);\n  }\n  return list;\n}\n\nmodule.exports = {\n  normalizeAttributes,\n  validateAttributeGroup,\n  upsertGroup,\n};\n"
    },
    {
      "path": "__tests__/attributeGroups.local.test.js",
      "content": "const assert = require('assert');\nconst { normalizeAttributes, validateAttributeGroup, upsertGroup } = require('../lib/attributeGroups');\n\n(function testNormalizeAttributes() {\n  const input = 'Width, Height; Depth\\nHEIGHT; ';\n  const out = normalizeAttributes(input);\n  assert(Array.isArray(out), 'normalizeAttributes returns array');\n  const names = out.map((a) => a.name);\n  assert.deepStrictEqual(names.sort(), ['Depth', 'Height', 'Width'].sort(), 'dedup and trim works');\n})();\n\n(function testValidateDuplicateName() {\n  const existing = [\n    { id: '1', name: 'Dimensions', attributes: [{ name: 'Width' }] },\n    { id: '2', name: 'Materials', attributes: [{ name: 'Material' }] },\n  ];\n  const group = { id: '3', name: 'dimensions', attributes: [{ name: 'Height' }] };\n  const errs = validateAttributeGroup(group, existing);\n  assert(errs.some((e) => /already exists/i.test(e)), 'detects duplicate group name case-insensitively');\n})();\n\n(function testUpsertById() {\n  const g1 = { id: '1', name: 'A', attributes: [{ name: 'x' }], createdAt: '2022-01-01' };\n  const g2 = { id: '2', name: 'B', attributes: [{ name: 'y' }], createdAt: '2022-01-02' };\n  const list = [g1, g2];\n  const updated = upsertGroup(list, { id: '2', name: 'B2', attributes: [{ name: 'y' }] });\n  assert.strictEqual(updated.length, 2, 'no change in length on update');\n  assert.strictEqual(updated[1].name, 'B2', 'updated at correct index');\n})();\n\nconsole.log('attributeGroups.local.test.js passed');\n"
    },
    {
      "path": "commit_message.txt",
      "content": "Feature: Add client-side Attribute Groups admin page with localStorage persistence and utility functions, plus unit test for normalization/validation."
    }
  ]
}