{
  "files": [
    {
      "path": "pages/api/attribute-groups/flat.js",
      "content": "export default async function handler(req, res) {\n  try {\n    if (req.method !== 'GET') {\n      res.setHeader('Allow', 'GET');\n      return res.status(405).json({ error: 'Method Not Allowed' });\n    }\n\n    // Load groups from static data (can be replaced by a persistent store later)\n    const groups = require('../../../data/attribute-groups.json');\n\n    const { q, type, groupId } = req.query || {};\n\n    const attributes = [];\n    for (const g of Array.isArray(groups) ? groups : []) {\n      if (groupId && String(g.id) !== String(groupId)) continue;\n      const list = Array.isArray(g.attributes) ? g.attributes : [];\n      for (const attr of list) {\n        const item = {\n          ...attr,\n          groupId: g.id,\n          groupName: g.name,\n        };\n        attributes.push(item);\n      }\n    }\n\n    // Optional filtering by query and type\n    const filtered = attributes.filter((a) => {\n      if (type && String(a.type) !== String(type)) return false;\n      if (q) {\n        const ql = String(q).toLowerCase();\n        const hay = [a.code, a.label, a.name, a.groupName].filter(Boolean).map((s) => String(s).toLowerCase());\n        if (!hay.some((h) => h.includes(ql))) return false;\n      }\n      return true;\n    });\n\n    res.setHeader('Content-Type', 'application/json');\n    return res.status(200).json({ count: filtered.length, attributes: filtered });\n  } catch (err) {\n    console.error('Attribute groups flat handler error', err);\n    return res.status(500).json({ error: 'Internal Server Error' });\n  }\n}\n"
    },
    {
      "path": "tests/api-attribute-groups-flat.test.js",
      "content": "const handlerModule = require('../pages/api/attribute-groups/flat');\nconst handler = handlerModule.default || handlerModule;\n\nfunction createMockRes() {\n  return {\n    statusCode: 200,\n    headers: {},\n    body: undefined,\n    setHeader(name, value) {\n      this.headers[name] = value;\n    },\n    status(code) {\n      this.statusCode = code;\n      return this;\n    },\n    json(payload) {\n      this.body = payload;\n      return this;\n    },\n  };\n}\n\ndescribe('GET /api/attribute-groups/flat', () => {\n  test('returns flattened attributes with group metadata', async () => {\n    const req = { method: 'GET', query: {} };\n    const res = createMockRes();\n    await handler(req, res);\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toBeDefined();\n    expect(Array.isArray(res.body.attributes)).toBe(true);\n    expect(res.body.count).toBe(res.body.attributes.length);\n    const first = res.body.attributes[0];\n    expect(first).toHaveProperty('groupId');\n    expect(first).toHaveProperty('groupName');\n  });\n\n  test('supports filtering by type and q and groupId', async () => {\n    const req = { method: 'GET', query: { type: 'text' } };\n    const res = createMockRes();\n    await handler(req, res);\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.attributes)).toBe(true);\n    // All returned must match the requested type\n    for (const a of res.body.attributes) {\n      expect(String(a.type)).toBe('text');\n    }\n\n    const groups = require('../data/attribute-groups.json');\n    const oneGroup = Array.isArray(groups) && groups[0] ? groups[0] : null;\n    if (oneGroup) {\n      const req2 = { method: 'GET', query: { groupId: String(oneGroup.id), q: String(oneGroup.name).slice(0, 2) } };\n      const res2 = createMockRes();\n      await handler(req2, res2);\n      expect(res2.statusCode).toBe(200);\n      for (const a of res2.body.attributes) {\n        expect(String(a.groupId)).toBe(String(oneGroup.id));\n      }\n    }\n  });\n\n  test('rejects non-GET methods', async () => {\n    const req = { method: 'POST', body: {} };\n    const res = createMockRes();\n    await handler(req, res);\n    expect(res.statusCode).toBe(405);\n    expect(res.body).toHaveProperty('error');\n  });\n});\n"
    }
  ]
}