{
  "files": [
    {
      "path": "data/attribute-groups.json",
      "content": "{\n  \"groups\": [\n    {\n      \"id\": \"1\",\n      \"name\": \"General\",\n      \"attributes\": [\n        { \"code\": \"name\", \"label\": \"Name\", \"type\": \"text\" },\n        { \"code\": \"description\", \"label\": \"Description\", \"type\": \"text\" }\n      ],\n      \"createdAt\": \"2024-01-01T00:00:00.000Z\",\n      \"updatedAt\": \"2024-01-01T00:00:00.000Z\"\n    },\n    {\n      \"id\": \"2\",\n      \"name\": \"Pricing\",\n      \"attributes\": [\n        { \"code\": \"price\", \"label\": \"Price\", \"type\": \"number\" },\n        { \"code\": \"currency\", \"label\": \"Currency\", \"type\": \"select\", \"options\": [\"USD\", \"EUR\", \"GBP\"] }\n      ],\n      \"createdAt\": \"2024-01-01T00:00:00.000Z\",\n      \"updatedAt\": \"2024-01-01T00:00:00.000Z\"\n    }\n  ]\n}\n"
    },
    {
      "path": "lib/attributeGroups.js",
      "content": "'use strict';\n\n// Simple in-memory store seeded from repo data. In serverless, this persists per warm instance.\nconst seed = require('../data/attribute-groups.json');\n\nconst globalAny = global;\nif (!globalAny.__ATTRIBUTE_GROUPS__) {\n  const groups = Array.isArray(seed.groups) ? seed.groups.map((g) => ({ ...g })) : [];\n  const maxId = groups.reduce((m, g) => Math.max(m, parseInt(g.id, 10) || 0), 0);\n  globalAny.__ATTRIBUTE_GROUPS__ = {\n    groups,\n    nextId: String(maxId + 1),\n  };\n}\n\nfunction nowISO() {\n  return new Date().toISOString();\n}\n\nfunction clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction listGroups() {\n  return clone(globalAny.__ATTRIBUTE_GROUPS__.groups);\n}\n\nfunction getGroup(id) {\n  const g = globalAny.__ATTRIBUTE_GROUPS__.groups.find((x) => String(x.id) === String(id));\n  return g ? clone(g) : null;\n}\n\nfunction validateAttribute(attr, index) {\n  const errors = [];\n  if (!attr || typeof attr !== 'object') {\n    return [`attributes[${index}] must be an object`];\n  }\n  const { code, label, type, options } = attr;\n  if (!code || typeof code !== 'string' || !/^[-a-zA-Z0-9_]{1,64}$/.test(code)) {\n    errors.push(`attributes[${index}].code must match [-a-zA-Z0-9_]{1,64}`);\n  }\n  if (!label || typeof label !== 'string' || label.trim().length === 0 || label.length > 120) {\n    errors.push(`attributes[${index}].label is required (1-120 chars)`);\n  }\n  const allowed = ['text', 'number', 'boolean', 'select'];\n  if (!type || !allowed.includes(type)) {\n    errors.push(`attributes[${index}].type must be one of ${allowed.join(', ')}`);\n  }\n  if (type === 'select') {\n    if (!Array.isArray(options) || options.length === 0 || options.some((o) => typeof o !== 'string' || o.trim().length === 0)) {\n      errors.push(`attributes[${index}].options must be a non-empty array of strings for type 'select'`);\n    }\n  }\n  return errors;\n}\n\nfunction validateGroupPayload(payload) {\n  const errors = [];\n  if (!payload || typeof payload !== 'object') {\n    return { valid: false, errors: ['payload must be an object'] };\n  }\n\n  const value = {\n    name: payload.name,\n    attributes: Array.isArray(payload.attributes) ? payload.attributes : [],\n  };\n\n  if (!value.name || typeof value.name !== 'string' || value.name.trim().length === 0 || value.name.length > 100) {\n    errors.push('name is required (1-100 chars)');\n  }\n\n  if (!Array.isArray(value.attributes)) {\n    errors.push('attributes must be an array');\n  } else {\n    const attrCodes = new Set();\n    value.attributes.forEach((attr, i) => {\n      const errs = validateAttribute(attr, i);\n      errs.forEach((e) => errors.push(e));\n      if (attr && typeof attr.code === 'string') {\n        const lc = attr.code.toLowerCase();\n        if (attrCodes.has(lc)) {\n          errors.push(`attributes[${i}].code duplicates an existing code`);\n        }\n        attrCodes.add(lc);\n      }\n    });\n  }\n\n  return { valid: errors.length === 0, errors, value };\n}\n\nfunction ensureUniqueName(name, excludeId) {\n  const lc = name.trim().toLowerCase();\n  const exists = globalAny.__ATTRIBUTE_GROUPS__.groups.some(\n    (g) => g.name.trim().toLowerCase() === lc && String(g.id) !== String(excludeId)\n  );\n  if (exists) {\n    const err = new Error('name must be unique');\n    err.code = 'DUPLICATE_NAME';\n    throw err;\n  }\n}\n\nfunction createGroup(payload) {\n  const { valid, errors, value } = validateGroupPayload(payload);\n  if (!valid) {\n    const err = new Error('Validation failed');\n    err.code = 'VALIDATION_ERROR';\n    err.details = errors;\n    throw err;\n  }\n  ensureUniqueName(value.name);\n  const id = globalAny.__ATTRIBUTE_GROUPS__.nextId;\n  const timestamp = nowISO();\n  const group = {\n    id: String(id),\n    name: value.name.trim(),\n    attributes: clone(value.attributes),\n    createdAt: timestamp,\n    updatedAt: timestamp,\n  };\n  globalAny.__ATTRIBUTE_GROUPS__.groups.push(group);\n  globalAny.__ATTRIBUTE_GROUPS__.nextId = String(parseInt(id, 10) + 1);\n  return clone(group);\n}\n\nfunction updateGroup(id, payload) {\n  const { valid, errors, value } = validateGroupPayload(payload);\n  if (!valid) {\n    const err = new Error('Validation failed');\n    err.code = 'VALIDATION_ERROR';\n    err.details = errors;\n    throw err;\n  }\n  const idx = globalAny.__ATTRIBUTE_GROUPS__.groups.findIndex((x) => String(x.id) === String(id));\n  if (idx === -1) {\n    const err = new Error('Not Found');\n    err.code = 'NOT_FOUND';\n    throw err;\n  }\n  ensureUniqueName(value.name, id);\n  const existing = globalAny.__ATTRIBUTE_GROUPS__.groups[idx];\n  const updated = {\n    ...existing,\n    name: value.name.trim(),\n    attributes: clone(value.attributes),\n    updatedAt: nowISO(),\n  };\n  globalAny.__ATTRIBUTE_GROUPS__.groups[idx] = updated;\n  return clone(updated);\n}\n\nfunction deleteGroup(id) {\n  const idx = globalAny.__ATTRIBUTE_GROUPS__.groups.findIndex((x) => String(x.id) === String(id));\n  if (idx === -1) {\n    const err = new Error('Not Found');\n    err.code = 'NOT_FOUND';\n    throw err;\n  }\n  const removed = globalAny.__ATTRIBUTE_GROUPS__.groups.splice(idx, 1)[0];\n  return clone(removed);\n}\n\nmodule.exports = {\n  listGroups,\n  getGroup,\n  createGroup,\n  updateGroup,\n  deleteGroup,\n  validateGroupPayload,\n};\n"
    },
    {
      "path": "pages/api/attribute-groups/index.js",
      "content": "'use strict';\n\nconst {\n  listGroups,\n  createGroup,\n  validateGroupPayload,\n} = require('../../../lib/attributeGroups');\n\nmodule.exports = async function handler(req, res) {\n  res.setHeader('Content-Type', 'application/json; charset=utf-8');\n  if (req.method === 'GET') {\n    const groups = listGroups();\n    res.status(200).json({ data: groups });\n    return;\n  }\n  if (req.method === 'POST') {\n    try {\n      const body = req.body || {};\n      const { valid, errors } = validateGroupPayload(body);\n      if (!valid) {\n        res.status(400).json({ error: 'Validation failed', details: errors });\n        return;\n      }\n      const created = createGroup(body);\n      res.status(201).json({ data: created });\n      return;\n    } catch (e) {\n      if (e && e.code === 'DUPLICATE_NAME') {\n        res.status(409).json({ error: e.message });\n        return;\n      }\n      if (e && e.code === 'VALIDATION_ERROR') {\n        res.status(400).json({ error: e.message, details: e.details || [] });\n        return;\n      }\n      console.error('POST /api/attribute-groups error', e);\n      res.status(500).json({ error: 'Internal Server Error' });\n      return;\n    }\n  }\n\n  res.setHeader('Allow', 'GET, POST');\n  res.status(405).json({ error: 'Method Not Allowed' });\n};\n"
    },
    {
      "path": "pages/api/attribute-groups/[id].js",
      "content": "'use strict';\n\nconst {\n  getGroup,\n  updateGroup,\n  deleteGroup,\n  validateGroupPayload,\n} = require('../../../lib/attributeGroups');\n\nmodule.exports = async function handler(req, res) {\n  res.setHeader('Content-Type', 'application/json; charset=utf-8');\n  const { id } = req.query || {};\n\n  if (req.method === 'GET') {\n    const g = getGroup(id);\n    if (!g) {\n      res.status(404).json({ error: 'Not Found' });\n      return;\n    }\n    res.status(200).json({ data: g });\n    return;\n  }\n\n  if (req.method === 'PUT') {\n    try {\n      const body = req.body || {};\n      const { valid, errors } = validateGroupPayload(body);\n      if (!valid) {\n        res.status(400).json({ error: 'Validation failed', details: errors });\n        return;\n      }\n      const updated = updateGroup(id, body);\n      res.status(200).json({ data: updated });\n      return;\n    } catch (e) {\n      if (e && e.code === 'NOT_FOUND') {\n        res.status(404).json({ error: 'Not Found' });\n        return;\n      }\n      if (e && e.code === 'DUPLICATE_NAME') {\n        res.status(409).json({ error: e.message });\n        return;\n      }\n      if (e && e.code === 'VALIDATION_ERROR') {\n        res.status(400).json({ error: e.message, details: e.details || [] });\n        return;\n      }\n      console.error(`PUT /api/attribute-groups/${id} error`, e);\n      res.status(500).json({ error: 'Internal Server Error' });\n      return;\n    }\n  }\n\n  if (req.method === 'DELETE') {\n    try {\n      deleteGroup(id);\n      res.status(204).end();\n      return;\n    } catch (e) {\n      if (e && e.code === 'NOT_FOUND') {\n        res.status(404).json({ error: 'Not Found' });\n        return;\n      }\n      console.error(`DELETE /api/attribute-groups/${id} error`, e);\n      res.status(500).json({ error: 'Internal Server Error' });\n      return;\n    }\n  }\n\n  res.setHeader('Allow', 'GET, PUT, DELETE');\n  res.status(405).json({ error: 'Method Not Allowed' });\n};\n"
    },
    {
      "path": "pages/attribute-groups.js",
      "content": "import { useEffect, useState } from 'react';\n\nexport default function AttributeGroupsPage() {\n  const [groups, setGroups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState('');\n  const [name, setName] = useState('');\n  const [attrsText, setAttrsText] = useState('code:label:type\\ncolor:Color:select[Red|Green|Blue]');\n  const [submitting, setSubmitting] = useState(false);\n\n  async function load() {\n    try {\n      setLoading(true);\n      setError('');\n      const res = await fetch('/api/attribute-groups');\n      const json = await res.json();\n      if (!res.ok) throw new Error(json.error || 'Failed to load');\n      setGroups(json.data || []);\n    } catch (e) {\n      setError(e.message || 'Error');\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  useEffect(() => {\n    load();\n  }, []);\n\n  function parseAttributes(text) {\n    // Each line: code:label:type OR for select: code:label:select[Option1|Option2]\n    const lines = text\n      .split('\\n')\n      .map((l) => l.trim())\n      .filter((l) => l.length > 0);\n    const attrs = [];\n    for (const [i, line] of lines.entries()) {\n      const parts = line.split(':');\n      if (parts.length < 3) throw new Error(`Line ${i + 1}: Expected format code:label:type`);\n      const [code, label, typeRaw] = parts;\n      let type = typeRaw;\n      let options;\n      const m = typeRaw.match(/^select\\[(.*)\\]$/i);\n      if (m) {\n        type = 'select';\n        options = (m[1] || '')\n          .split('|')\n          .map((o) => o.trim())\n          .filter(Boolean);\n        if (options.length === 0) throw new Error(`Line ${i + 1}: select[] must include options`);\n      }\n      attrs.push({ code, label, type, ...(options ? { options } : {}) });\n    }\n    return attrs;\n  }\n\n  async function onSubmit(e) {\n    e.preventDefault();\n    if (submitting) return;\n    try {\n      setSubmitting(true);\n      setError('');\n      const attributes = parseAttributes(attrsText);\n      const res = await fetch('/api/attribute-groups', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name, attributes }),\n      });\n      const json = await res.json();\n      if (!res.ok) {\n        const details = json.details ? `: ${json.details.join('; ')}` : '';\n        throw new Error(json.error ? json.error + details : 'Failed to create');\n      }\n      setName('');\n      setAttrsText('');\n      await load();\n    } catch (e) {\n      setError(e.message || 'Error');\n    } finally {\n      setSubmitting(false);\n    }\n  }\n\n  return (\n    <div style={{ maxWidth: 900, margin: '20px auto', padding: '0 16px' }}>\n      <h1>Attribute Groups</h1>\n\n      <section style={{ marginBottom: 24, padding: 16, border: '1px solid #eee', borderRadius: 8 }}>\n        <h2 style={{ marginTop: 0 }}>Create New Group</h2>\n        <form onSubmit={onSubmit}>\n          <div style={{ marginBottom: 12 }}>\n            <label>\n              <div style={{ fontWeight: 600 }}>Name</div>\n              <input\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n                placeholder=\"e.g. Specifications\"\n                style={{ width: '100%', padding: 8 }}\n                required\n              />\n            </label>\n          </div>\n          <div style={{ marginBottom: 12 }}>\n            <label>\n              <div style={{ fontWeight: 600 }}>Attributes</div>\n              <textarea\n                value={attrsText}\n                onChange={(e) => setAttrsText(e.target.value)}\n                rows={5}\n                style={{ width: '100%', padding: 8, fontFamily: 'monospace' }}\n                placeholder={'code:label:type\\nsize:Size:number\\nis_active:Is Active:boolean\\ncolor:Color:select[Red|Green|Blue]'}\n              />\n            </label>\n            <div style={{ color: '#666', fontSize: 12, marginTop: 4 }}>\n              Format: code:label:type. For select, use select[Option1|Option2].\n            </div>\n          </div>\n          <button type=\"submit\" disabled={submitting} style={{ padding: '8px 12px' }}>\n            {submitting ? 'Creating…' : 'Create Group'}\n          </button>\n        </form>\n        {error ? (\n          <div style={{ color: 'crimson', marginTop: 12 }}>{error}</div>\n        ) : null}\n      </section>\n\n      <section>\n        <h2 style={{ marginTop: 0 }}>Existing Groups</h2>\n        {loading ? (\n          <div>Loading…</div>\n        ) : groups.length === 0 ? (\n          <div>No attribute groups yet.</div>\n        ) : (\n          <ul style={{ listStyle: 'none', padding: 0 }}>\n            {groups.map((g) => (\n              <li key={g.id} style={{ border: '1px solid #eee', borderRadius: 8, marginBottom: 12, padding: 12 }}>\n                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n                  <div>\n                    <div style={{ fontWeight: 700 }}>{g.name}</div>\n                    <div style={{ fontSize: 12, color: '#666' }}>ID: {g.id}</div>\n                  </div>\n                  <div style={{ fontSize: 12, color: '#666' }}>\n                    <span>Updated: {new Date(g.updatedAt).toLocaleString()}</span>\n                  </div>\n                </div>\n                <div style={{ marginTop: 8 }}>\n                  {g.attributes && g.attributes.length > 0 ? (\n                    <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n                      <thead>\n                        <tr>\n                          <th align=\"left\" style={{ borderBottom: '1px solid #ddd', padding: '4px 0' }}>Code</th>\n                          <th align=\"left\" style={{ borderBottom: '1px solid #ddd', padding: '4px 0' }}>Label</th>\n                          <th align=\"left\" style={{ borderBottom: '1px solid #ddd', padding: '4px 0' }}>Type</th>\n                          <th align=\"left\" style={{ borderBottom: '1px solid #ddd', padding: '4px 0' }}>Options</th>\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {g.attributes.map((a) => (\n                          <tr key={a.code}>\n                            <td style={{ padding: '4px 0' }}>{a.code}</td>\n                            <td style={{ padding: '4px 0' }}>{a.label}</td>\n                            <td style={{ padding: '4px 0' }}>{a.type}</td>\n                            <td style={{ padding: '4px 0' }}>{Array.isArray(a.options) ? a.options.join(', ') : ''}</td>\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  ) : (\n                    <div style={{ color: '#666' }}>No attributes</div>\n                  )}\n                </div>\n              </li>\n            ))}\n          </ul>\n        )}\n      </section>\n    </div>\n  );\n}\n"
    },
    {
      "path": "tests/attributeGroups.test.js",
      "content": "'use strict';\n\n// Simple node test using built-in assert; run with `node tests/attributeGroups.test.js`\nconst assert = require('assert');\nconst { validateGroupPayload } = require('../lib/attributeGroups');\n\n(function testValidPayload() {\n  const payload = {\n    name: 'Specifications',\n    attributes: [\n      { code: 'weight', label: 'Weight', type: 'number' },\n      { code: 'is_active', label: 'Is Active', type: 'boolean' },\n      { code: 'color', label: 'Color', type: 'select', options: ['Red', 'Green'] },\n    ],\n  };\n  const res = validateGroupPayload(payload);\n  assert.strictEqual(res.valid, true, 'Expected payload to be valid');\n  assert.deepStrictEqual(res.errors, [], 'Expected no validation errors');\n})();\n\n(function testInvalidPayload() {\n  const payload = {\n    name: '', // invalid\n    attributes: [\n      { code: 'bad code', label: '', type: 'text' }, // invalid code and label\n      { code: 'color', label: 'Color', type: 'select', options: [] }, // invalid options\n      { code: 'color', label: 'Dup Code', type: 'text' }, // duplicate code\n    ],\n  };\n  const res = validateGroupPayload(payload);\n  assert.strictEqual(res.valid, false, 'Expected payload to be invalid');\n  assert.ok(res.errors.length >= 3, 'Expected multiple validation errors');\n})();\n\nconsole.log('attributeGroups tests passed');\n"
    }
  ]
}