{
  "files": [
    {
      "path": "lib/attributeGroups.js",
      "content": "const STORAGE_KEY = 'pim.attributeGroups.v1';\n\n// Simple in-memory storage fallback for SSR and tests\nconst createMemoryStorage = () => {\n  const store = new Map();\n  return {\n    getItem: (key) => {\n      const v = store.get(key);\n      return typeof v === 'undefined' ? null : String(v);\n    },\n    setItem: (key, value) => {\n      store.set(key, String(value));\n    },\n    removeItem: (key) => {\n      store.delete(key);\n    },\n    clear: () => store.clear(),\n    _dump: () => Object.fromEntries(store.entries()),\n  };\n};\n\nconst memoryStorage = createMemoryStorage();\n\nfunction getDefaultStorage() {\n  if (typeof window !== 'undefined' && window && window.localStorage) {\n    return window.localStorage;\n  }\n  return memoryStorage;\n}\n\nfunction safeParse(json, fallback) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return fallback;\n  }\n}\n\nfunction generateId() {\n  // Collision-resistant enough for client-side usage\n  const rand = Math.random().toString(36).slice(2, 8);\n  const time = Date.now().toString(36);\n  return `${time}-${rand}`;\n}\n\nfunction loadGroups(storage = getDefaultStorage()) {\n  const raw = storage.getItem(STORAGE_KEY);\n  const groups = safeParse(raw, []);\n  if (!Array.isArray(groups)) return [];\n  return groups;\n}\n\nfunction saveGroups(groups, storage = getDefaultStorage()) {\n  const data = Array.isArray(groups) ? groups : [];\n  storage.setItem(STORAGE_KEY, JSON.stringify(data));\n  return data;\n}\n\nfunction createGroup({ name, description = '', attributes = [] }) {\n  const id = generateId();\n  const normalizedAttrs = Array.isArray(attributes)\n    ? attributes.map((a) => String(a).trim()).filter(Boolean)\n    : [];\n  return { id, name: String(name || '').trim(), description: String(description || '').trim(), attributes: normalizedAttrs };\n}\n\nfunction upsertGroup(group, storage = getDefaultStorage()) {\n  const groups = loadGroups(storage);\n  const idx = groups.findIndex((g) => g.id === group.id);\n  let next;\n  if (idx === -1) {\n    next = [...groups, group];\n  } else {\n    next = groups.slice();\n    next[idx] = group;\n  }\n  saveGroups(next, storage);\n  return next;\n}\n\nfunction deleteGroup(id, storage = getDefaultStorage()) {\n  const groups = loadGroups(storage);\n  const next = groups.filter((g) => g.id !== id);\n  saveGroups(next, storage);\n  return next;\n}\n\nfunction clearAll(storage = getDefaultStorage()) {\n  storage.removeItem(STORAGE_KEY);\n}\n\nmodule.exports = {\n  STORAGE_KEY,\n  memoryStorage,\n  getDefaultStorage,\n  loadGroups,\n  saveGroups,\n  createGroup,\n  upsertGroup,\n  deleteGroup,\n  clearAll,\n};\n"
    },
    {
      "path": "pages/admin/attribute-groups.jsx",
      "content": "import { useEffect, useMemo, useState } from 'react';\nimport Head from 'next/head';\n\nconst {\n  loadGroups,\n  saveGroups,\n  createGroup,\n  upsertGroup,\n  deleteGroup,\n} = require('../../lib/attributeGroups');\n\nexport default function AttributeGroupsPage() {\n  const [mounted, setMounted] = useState(false);\n  const [groups, setGroups] = useState([]);\n  const [editingId, setEditingId] = useState(null);\n  const [form, setForm] = useState({ name: '', description: '', attrs: '' });\n  const [filter, setFilter] = useState('');\n\n  useEffect(() => {\n    setMounted(true);\n    try {\n      const g = loadGroups();\n      setGroups(g);\n    } catch (e) {\n      // ignore\n    }\n  }, []);\n\n  const filtered = useMemo(() => {\n    const q = filter.trim().toLowerCase();\n    if (!q) return groups;\n    return groups.filter((g) =>\n      (g.name || '').toLowerCase().includes(q) ||\n      (g.description || '').toLowerCase().includes(q) ||\n      (g.attributes || []).some((a) => (a || '').toLowerCase().includes(q))\n    );\n  }, [groups, filter]);\n\n  function resetForm() {\n    setEditingId(null);\n    setForm({ name: '', description: '', attrs: '' });\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    const name = (form.name || '').trim();\n    if (!name) return;\n    const description = (form.description || '').trim();\n    const attributes = (form.attrs || '')\n      .split(',')\n      .map((s) => s.trim())\n      .filter(Boolean);\n\n    if (editingId) {\n      const existing = groups.find((g) => g.id === editingId);\n      if (!existing) {\n        resetForm();\n        return;\n      }\n      const updated = { ...existing, name, description, attributes };\n      const next = upsertGroup(updated);\n      setGroups(next);\n      resetForm();\n    } else {\n      const group = createGroup({ name, description, attributes });\n      const next = upsertGroup(group);\n      setGroups(next);\n      resetForm();\n    }\n  }\n\n  function startEdit(id) {\n    const g = groups.find((x) => x.id === id);\n    if (!g) return;\n    setEditingId(g.id);\n    setForm({ name: g.name || '', description: g.description || '', attrs: (g.attributes || []).join(', ') });\n  }\n\n  function remove(id) {\n    const next = deleteGroup(id);\n    setGroups(next);\n    if (editingId === id) resetForm();\n  }\n\n  function importJson(text) {\n    try {\n      const parsed = JSON.parse(text);\n      if (!Array.isArray(parsed)) return false;\n      const normalized = parsed.map((g) => ({\n        id: String(g.id || ''),\n        name: String(g.name || ''),\n        description: String(g.description || ''),\n        attributes: Array.isArray(g.attributes) ? g.attributes.map((a) => String(a)) : [],\n      })).filter((g) => g.id && g.name);\n      saveGroups(normalized);\n      setGroups(normalized);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  if (!mounted) return null;\n\n  return (\n    <div style={styles.page}>\n      <Head>\n        <title>Attribute Groups â€¢ Simple PIM</title>\n      </Head>\n      <header style={styles.header}>\n        <h1 style={{ margin: 0 }}>Attribute Groups</h1>\n        <p style={{ margin: '4px 0 0 0', color: '#555' }}>Group attributes to structure your catalog (e.g., \"Dimensions\", \"Materials\"). Stored locally in your browser.</p>\n      </header>\n\n      <section style={styles.section}>\n        <form onSubmit={handleSubmit} style={styles.card}>\n          <h2 style={styles.h2}>{editingId ? 'Edit Group' : 'New Group'}</h2>\n          <div style={styles.row}>\n            <label style={styles.label}>Name</label>\n            <input\n              style={styles.input}\n              value={form.name}\n              onChange={(e) => setForm({ ...form, name: e.target.value })}\n              placeholder=\"e.g., Dimensions\"\n            />\n          </div>\n          <div style={styles.row}>\n            <label style={styles.label}>Description</label>\n            <input\n              style={styles.input}\n              value={form.description}\n              onChange={(e) => setForm({ ...form, description: e.target.value })}\n              placeholder=\"Optional\"\n            />\n          </div>\n          <div style={styles.row}>\n            <label style={styles.label}>Attributes</label>\n            <input\n              style={styles.input}\n              value={form.attrs}\n              onChange={(e) => setForm({ ...form, attrs: e.target.value })}\n              placeholder=\"Comma-separated, e.g., Width, Height, Depth\"\n            />\n          </div>\n          <div style={{ display: 'flex', gap: 8 }}>\n            <button type=\"submit\" style={styles.primaryBtn}>{editingId ? 'Save Changes' : 'Add Group'}</button>\n            {editingId ? (\n              <button type=\"button\" style={styles.btn} onClick={resetForm}>Cancel</button>\n            ) : null}\n          </div>\n        </form>\n\n        <div style={styles.card}>\n          <h2 style={styles.h2}>Groups</h2>\n          <div style={{ marginBottom: 8 }}>\n            <input\n              style={styles.input}\n              value={filter}\n              onChange={(e) => setFilter(e.target.value)}\n              placeholder=\"Filter groups...\"\n            />\n          </div>\n          {filtered.length === 0 ? (\n            <p style={{ color: '#666' }}>No groups yet.</p>\n          ) : (\n            <ul style={{ listStyle: 'none', margin: 0, padding: 0 }}>\n              {filtered.map((g) => (\n                <li key={g.id} style={styles.groupItem}>\n                  <div style={{ flex: 1 }}>\n                    <div style={{ fontWeight: 600 }}>{g.name}</div>\n                    {g.description ? (\n                      <div style={{ color: '#555', fontSize: 13 }}>{g.description}</div>\n                    ) : null}\n                    <div style={{ marginTop: 6, display: 'flex', flexWrap: 'wrap', gap: 6 }}>\n                      {(g.attributes || []).map((a, i) => (\n                        <span key={i} style={styles.pill}>{a}</span>\n                      ))}\n                    </div>\n                  </div>\n                  <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>\n                    <button style={styles.btn} onClick={() => startEdit(g.id)}>Edit</button>\n                    <button style={styles.dangerBtn} onClick={() => remove(g.id)}>Delete</button>\n                  </div>\n                </li>\n              ))}\n            </ul>\n          )}\n        </div>\n\n        <div style={styles.card}>\n          <h2 style={styles.h2}>Import / Export</h2>\n          <p style={{ color: '#555', marginTop: 0 }}>Export your groups as JSON, or import from a JSON array.</p>\n          <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>\n            <button\n              style={styles.btn}\n              onClick={() => {\n                const data = JSON.stringify(groups, null, 2);\n                const blob = new Blob([data], { type: 'application/json' });\n                const url = URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = 'attribute-groups.json';\n                a.click();\n                URL.revokeObjectURL(url);\n              }}\n            >Export JSON</button>\n            <label style={{ ...styles.btn, cursor: 'pointer' }}>\n              Import JSON\n              <input\n                type=\"file\"\n                accept=\"application/json,.json\"\n                style={{ display: 'none' }}\n                onChange={async (e) => {\n                  const file = e.target.files && e.target.files[0];\n                  if (!file) return;\n                  const text = await file.text();\n                  const ok = importJson(text);\n                  if (!ok) alert('Invalid JSON format. Expected an array of groups.');\n                  e.target.value = '';\n                }}\n              />\n            </label>\n          </div>\n        </div>\n      </section>\n    </div>\n  );\n}\n\nconst styles = {\n  page: {\n    padding: 20,\n    fontFamily: '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif',\n  },\n  header: {\n    marginBottom: 16,\n  },\n  section: {\n    display: 'grid',\n    gridTemplateColumns: '1fr',\n    gap: 16,\n  },\n  card: {\n    border: '1px solid #e5e7eb',\n    borderRadius: 8,\n    padding: 16,\n    background: 'white',\n    boxShadow: '0 1px 2px rgba(0,0,0,0.04)',\n  },\n  h2: {\n    margin: '0 0 12px 0',\n    fontSize: 18,\n  },\n  row: {\n    display: 'flex',\n    flexDirection: 'column',\n    marginBottom: 10,\n  },\n  label: {\n    fontSize: 13,\n    color: '#555',\n    marginBottom: 4,\n  },\n  input: {\n    padding: '10px 12px',\n    borderRadius: 6,\n    border: '1px solid #d1d5db',\n    outline: 'none',\n    width: '100%',\n  },\n  btn: {\n    background: '#f3f4f6',\n    color: '#111827',\n    border: '1px solid #e5e7eb',\n    padding: '8px 12px',\n    borderRadius: 6,\n    cursor: 'pointer',\n  },\n  primaryBtn: {\n    background: '#111827',\n    color: 'white',\n    border: '1px solid #111827',\n    padding: '8px 12px',\n    borderRadius: 6,\n    cursor: 'pointer',\n  },\n  dangerBtn: {\n    background: '#fee2e2',\n    color: '#991b1b',\n    border: '1px solid #fecaca',\n    padding: '8px 12px',\n    borderRadius: 6,\n    cursor: 'pointer',\n  },\n  groupItem: {\n    display: 'flex',\n    gap: 12,\n    alignItems: 'flex-start',\n    justifyContent: 'space-between',\n    padding: '10px 0',\n    borderBottom: '1px solid #f3f4f6',\n  },\n  pill: {\n    fontSize: 12,\n    padding: '4px 8px',\n    background: '#f3f4f6',\n    borderRadius: 999,\n  },\n};\n"
    },
    {
      "path": "__tests__/attributeGroups.test.js",
      "content": "const assert = require('assert');\nconst {\n  memoryStorage,\n  loadGroups,\n  saveGroups,\n  createGroup,\n  upsertGroup,\n  deleteGroup,\n  clearAll,\n} = require('../lib/attributeGroups');\n\n// Basic unit tests for attribute group helpers\n(function run() {\n  const store = { ...memoryStorage }; // shallow copy methods but independent storage not guaranteed; create a fresh one instead\n  // create a fresh memory storage\n  const createStore = () => {\n    const map = new Map();\n    return {\n      getItem: (k) => (map.has(k) ? map.get(k) : null),\n      setItem: (k, v) => map.set(k, String(v)),\n      removeItem: (k) => map.delete(k),\n      clear: () => map.clear(),\n    };\n  };\n\n  const s = createStore();\n  clearAll(s);\n\n  assert.deepStrictEqual(loadGroups(s), [], 'initial groups should be empty');\n\n  const g1 = createGroup({ name: 'Dimensions', description: 'Physical measures', attributes: ['Width', 'Height', 'Depth'] });\n  const afterInsert = upsertGroup(g1, s);\n  assert.strictEqual(afterInsert.length, 1, 'one group after insert');\n  assert.strictEqual(afterInsert[0].name, 'Dimensions');\n\n  const g1Updated = { ...g1, description: 'Size related', attributes: ['Width', 'Height'] };\n  const afterUpdate = upsertGroup(g1Updated, s);\n  assert.strictEqual(afterUpdate[0].description, 'Size related', 'updated description persists');\n  assert.deepStrictEqual(afterUpdate[0].attributes, ['Width', 'Height'], 'updated attributes persist');\n\n  const afterDelete = deleteGroup(g1.id, s);\n  assert.strictEqual(afterDelete.length, 0, 'group deleted');\n\n  // Save and load roundtrip\n  saveGroups([g1], s);\n  const loaded = loadGroups(s);\n  assert.strictEqual(loaded.length, 1, 'roundtrip load works');\n\n  // If reached here without throwing, test passed\n  console.log('attributeGroups tests passed');\n})();\n"
    }
  ]
}