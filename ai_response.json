{
  "files": [
    {
      "path": "lib/attributeGroups.js",
      "content": "const STORAGE_KEY = 'pim.attributeGroups';\n\nfunction getStorage() {\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) return window.localStorage;\n  } catch (e) {}\n  try {\n    if (typeof global !== 'undefined' && global.localStorage) return global.localStorage;\n  } catch (e) {}\n  return null;\n}\n\nfunction safeParse(json, fallback) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return fallback;\n  }\n}\n\nfunction loadAttributeGroups() {\n  const storage = getStorage();\n  if (!storage) return [];\n  const raw = storage.getItem(STORAGE_KEY);\n  if (!raw) return [];\n  const data = safeParse(raw, []);\n  if (!Array.isArray(data)) return [];\n  return data;\n}\n\nfunction saveAttributeGroups(groups) {\n  const storage = getStorage();\n  if (!storage) return;\n  try {\n    storage.setItem(STORAGE_KEY, JSON.stringify(groups || []));\n  } catch (e) {\n    // ignore quota or serialization errors\n  }\n}\n\nfunction generateId(prefix = 'ag') {\n  return `${prefix}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction upsertGroup(groups, group) {\n  const list = Array.isArray(groups) ? groups.slice() : [];\n  const idx = group && group.id ? list.findIndex(g => g.id === group.id) : -1;\n  let next;\n  if (idx >= 0) {\n    next = list.slice();\n    next[idx] = { ...list[idx], ...group };\n  } else {\n    const id = group.id || generateId('ag');\n    next = list.concat([{ id, name: group.name || '', description: group.description || '', attributes: group.attributes || [] }]);\n    group = { ...group, id };\n  }\n  return { list: next, group };\n}\n\nfunction removeGroup(groups, id) {\n  return (Array.isArray(groups) ? groups : []).filter(g => g.id !== id);\n}\n\nfunction upsertAttribute(group, attribute) {\n  const g = { ...group };\n  const attrs = Array.isArray(g.attributes) ? g.attributes.slice() : [];\n  const idx = attribute && attribute.id ? attrs.findIndex(a => a.id === attribute.id) : -1;\n  if (idx >= 0) {\n    attrs[idx] = { ...attrs[idx], ...attribute };\n  } else {\n    attrs.push({ id: attribute.id || generateId('attr'), code: attribute.code || '', label: attribute.label || '', type: attribute.type || 'text', options: attribute.options || [] });\n  }\n  g.attributes = attrs;\n  return g;\n}\n\nfunction removeAttribute(group, attrId) {\n  const g = { ...group };\n  g.attributes = (Array.isArray(g.attributes) ? g.attributes : []).filter(a => a.id !== attrId);\n  return g;\n}\n\nmodule.exports = {\n  STORAGE_KEY,\n  getStorage,\n  loadAttributeGroups,\n  saveAttributeGroups,\n  generateId,\n  upsertGroup,\n  removeGroup,\n  upsertAttribute,\n  removeAttribute,\n};\n"
    },
    {
      "path": "pages/admin/attribute-groups.js",
      "content": "import React from 'react';\nconst {\n  loadAttributeGroups,\n  saveAttributeGroups,\n  generateId,\n  upsertGroup,\n  removeGroup,\n  upsertAttribute,\n  removeAttribute,\n} = require('../../lib/attributeGroups');\n\nexport default function AttributeGroupsPage() {\n  const [mounted, setMounted] = React.useState(false);\n  const [groups, setGroups] = React.useState([]);\n  const [newGroup, setNewGroup] = React.useState({ name: '', description: '' });\n\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  React.useEffect(() => {\n    if (!mounted) return;\n    const data = loadAttributeGroups();\n    setGroups(Array.isArray(data) ? data : []);\n  }, [mounted]);\n\n  React.useEffect(() => {\n    if (!mounted) return;\n    saveAttributeGroups(groups);\n  }, [groups, mounted]);\n\n  function handleAddGroup(e) {\n    e.preventDefault();\n    const name = (newGroup.name || '').trim();\n    if (!name) return;\n    const { list } = upsertGroup(groups, { name, description: newGroup.description || '', attributes: [] });\n    setGroups(list);\n    setNewGroup({ name: '', description: '' });\n  }\n\n  function handleUpdateGroup(id, patch) {\n    setGroups(prev => prev.map(g => (g.id === id ? { ...g, ...patch } : g)));\n  }\n\n  function handleRemoveGroup(id) {\n    if (!confirm('Delete this attribute group?')) return;\n    setGroups(prev => removeGroup(prev, id));\n  }\n\n  function handleAddAttribute(groupId) {\n    setGroups(prev => prev.map(g => {\n      if (g.id !== groupId) return g;\n      const attr = { id: generateId('attr'), code: '', label: '', type: 'text', options: [] };\n      return { ...g, attributes: [...(g.attributes || []), attr] };\n    }));\n  }\n\n  function handleUpdateAttribute(groupId, attrId, patch) {\n    setGroups(prev => prev.map(g => {\n      if (g.id !== groupId) return g;\n      const updated = (g.attributes || []).map(a => (a.id === attrId ? { ...a, ...patch } : a));\n      return { ...g, attributes: updated };\n    }));\n  }\n\n  function handleRemoveAttribute(groupId, attrId) {\n    setGroups(prev => prev.map(g => (g.id === groupId ? removeAttribute(g, attrId) : g)));\n  }\n\n  if (!mounted) return <div style={{ padding: 20 }}>Loading…</div>;\n\n  return (\n    <div style={{ padding: 20, maxWidth: 960, margin: '0 auto', fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif' }}>\n      <h1 style={{ marginBottom: 8 }}>Attribute Groups</h1>\n      <p style={{ color: '#555', marginTop: 0 }}>Organize product attributes into reusable groups. Data is stored locally in your browser.</p>\n\n      <form onSubmit={handleAddGroup} style={{ display: 'flex', gap: 8, flexWrap: 'wrap', alignItems: 'flex-end', background: '#fafafa', padding: 12, border: '1px solid #eee', borderRadius: 6 }}>\n        <div style={{ display: 'flex', flexDirection: 'column' }}>\n          <label style={{ fontSize: 12, color: '#555' }}>Group name</label>\n          <input value={newGroup.name} onChange={e => setNewGroup({ ...newGroup, name: e.target.value })} placeholder=\"e.g. Basic Details\" required style={{ padding: 8, minWidth: 240 }} />\n        </div>\n        <div style={{ display: 'flex', flexDirection: 'column', flex: 1, minWidth: 240 }}>\n          <label style={{ fontSize: 12, color: '#555' }}>Description</label>\n          <input value={newGroup.description} onChange={e => setNewGroup({ ...newGroup, description: e.target.value })} placeholder=\"Optional\" style={{ padding: 8 }} />\n        </div>\n        <button type=\"submit\" style={{ padding: '8px 12px' }}>Add group</button>\n      </form>\n\n      <div style={{ marginTop: 16, display: 'grid', gap: 12 }}>\n        {groups.length === 0 && (\n          <div style={{ color: '#666', fontStyle: 'italic' }}>No attribute groups yet. Create your first group above.</div>\n        )}\n        {groups.map(group => (\n          <div key={group.id} style={{ border: '1px solid #e5e5e5', borderRadius: 6, overflow: 'hidden' }}>\n            <div style={{ padding: 12, display: 'flex', alignItems: 'center', gap: 8, background: '#f7f7f7' }}>\n              <input value={group.name} onChange={e => handleUpdateGroup(group.id, { name: e.target.value })} placeholder=\"Group name\" style={{ padding: 8, flex: 1, fontWeight: 600 }} />\n              <button onClick={() => handleRemoveGroup(group.id)} style={{ padding: '6px 10px', background: '#ffe9e9', border: '1px solid #f5c2c2' }}>Delete</button>\n            </div>\n            <div style={{ padding: 12, display: 'flex', flexDirection: 'column', gap: 8 }}>\n              <input value={group.description || ''} onChange={e => handleUpdateGroup(group.id, { description: e.target.value })} placeholder=\"Description (optional)\" style={{ padding: 8 }} />\n\n              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: 8 }}>\n                <strong>Attributes</strong>\n                <button onClick={() => handleAddAttribute(group.id)} style={{ padding: '6px 10px' }}>Add attribute</button>\n              </div>\n\n              {(group.attributes || []).length === 0 && (\n                <div style={{ color: '#666', fontStyle: 'italic' }}>No attributes in this group yet.</div>\n              )}\n\n              {(group.attributes || []).map(attr => (\n                <div key={attr.id} style={{ display: 'grid', gridTemplateColumns: '1.2fr 1.2fr 1fr 1.5fr auto', gap: 8, alignItems: 'center' }}>\n                  <input value={attr.code} onChange={e => handleUpdateAttribute(group.id, attr.id, { code: e.target.value })} placeholder=\"code (unique)\" style={{ padding: 8 }} />\n                  <input value={attr.label} onChange={e => handleUpdateAttribute(group.id, attr.id, { label: e.target.value })} placeholder=\"Label\" style={{ padding: 8 }} />\n                  <select value={attr.type || 'text'} onChange={e => handleUpdateAttribute(group.id, attr.id, { type: e.target.value })} style={{ padding: 8 }}>\n                    <option value=\"text\">Text</option>\n                    <option value=\"number\">Number</option>\n                    <option value=\"select\">Select</option>\n                    <option value=\"boolean\">Boolean</option>\n                  </select>\n                  {attr.type === 'select' ? (\n                    <input value={(attr.options || []).join(', ')} onChange={e => handleUpdateAttribute(group.id, attr.id, { options: e.target.value.split(',').map(s => s.trim()).filter(Boolean) })} placeholder=\"Options (comma separated)\" style={{ padding: 8 }} />\n                  ) : (\n                    <div style={{ color: '#888', fontSize: 12 }}>—</div>\n                  )}\n                  <button onClick={() => handleRemoveAttribute(group.id, attr.id)} style={{ padding: '6px 10px', background: '#ffe9e9', border: '1px solid #f5c2c2' }}>Remove</button>\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n"
    },
    {
      "path": "__tests__/attributeGroups.test.js",
      "content": "/*\n  Simple test for lib/attributeGroups using a minimal in-memory localStorage polyfill.\n  This file is intentionally framework-agnostic; if Jest is present, you can run it.\n*/\n\nconst assert = require('assert');\n\nclass MemoryStorage {\n  constructor() { this._s = {}; }\n  getItem(k) { return Object.prototype.hasOwnProperty.call(this._s, k) ? this._s[k] : null; }\n  setItem(k, v) { this._s[k] = String(v); }\n  removeItem(k) { delete this._s[k]; }\n  clear() { this._s = {}; }\n}\n\nglobal.localStorage = new MemoryStorage();\n\nconst ag = require('../lib/attributeGroups');\n\n(function testSaveLoad() {\n  const groups = ag.loadAttributeGroups();\n  assert(Array.isArray(groups) && groups.length === 0, 'Should start empty');\n\n  const { list, group } = ag.upsertGroup([], { name: 'Basic', description: 'Common fields' });\n  assert(group.id, 'Group should have id');\n  assert(list.length === 1, 'List should have one group');\n  ag.saveAttributeGroups(list);\n\n  const loaded = ag.loadAttributeGroups();\n  assert(loaded.length === 1 && loaded[0].name === 'Basic', 'Should persist and load same group');\n\n  const g2 = ag.upsertAttribute(loaded[0], { code: 'brand', label: 'Brand', type: 'text' });\n  assert(g2.attributes.length === 1 && g2.attributes[0].code === 'brand', 'Attribute should be added');\n\n  console.log('attributeGroups: OK');\n})();\n"
    }
  ]
}