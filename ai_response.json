{
  "commit_message": "feat(api): add products variants summary endpoint and tests",
  "files": [
    {
      "path": "pages/api/products/variants-summary.js",
      "content": "import productsData from '../../../data/products.json';\n\nexport default function handler(req, res) {\n  try {\n    const products = Array.isArray(productsData) ? productsData : [];\n\n    const totalProducts = products.length;\n    let totalVariants = 0;\n    const productsWithVariants = [];\n    const variantsByProduct = {};\n    const attributeValueCounts = {};\n\n    products.forEach((p) => {\n      const sku = p.sku || p.id || p.name || 'unknown';\n      const variants = Array.isArray(p.variants) ? p.variants : [];\n      const vCount = variants.length;\n\n      totalVariants += vCount;\n      if (vCount > 0) productsWithVariants.push(sku);\n      variantsByProduct[sku] = vCount;\n\n      variants.forEach((v) => {\n        const attrs = v.attributes || {};\n        Object.keys(attrs).forEach((attrKey) => {\n          const val = attrs[attrKey];\n          if (val == null) return;\n          attributeValueCounts[attrKey] = attributeValueCounts[attrKey] || {};\n          attributeValueCounts[attrKey][String(val)] = (attributeValueCounts[attrKey][String(val)] || 0) + 1;\n        });\n      });\n    });\n\n    res.status(200).json({\n      totalProducts,\n      totalVariants,\n      productsWithVariants: productsWithVariants.length,\n      variantsByProduct,\n      attributeValueCounts,\n    });\n  } catch (err) {\n    // Keep error shape consistent for clients\n    res.status(500).json({ error: String(err) });\n  }\n}\n"
    },
    {
      "path": "tests/api-products-variants-summary.test.js",
      "content": "const handler = require('../pages/api/products/variants-summary').default;\nconst products = require('../data/products.json');\n\nfunction createMockRes() {\n  const json = jest.fn();\n  const status = jest.fn(() => ({ json }));\n  return { status, json };\n}\n\ntest('GET /api/products/variants-summary returns aggregated variant data', async () => {\n  const req = { method: 'GET' };\n  const res = createMockRes();\n\n  await handler(req, res);\n\n  // Build expected values from the source data\n  const expectedTotalProducts = products.length;\n  const expectedTotalVariants = products.reduce((acc, p) => acc + (Array.isArray(p.variants) ? p.variants.length : 0), 0);\n  const expectedProductsWithVariants = products.filter((p) => Array.isArray(p.variants) && p.variants.length > 0).length;\n\n  const expectedVariantsByProduct = {};\n  const expectedAttributeValueCounts = {};\n\n  products.forEach((p) => {\n    const sku = p.sku || p.id || p.name || 'unknown';\n    const variants = Array.isArray(p.variants) ? p.variants : [];\n    expectedVariantsByProduct[sku] = variants.length;\n\n    variants.forEach((v) => {\n      const attrs = v.attributes || {};\n      Object.keys(attrs).forEach((attrKey) => {\n        const val = attrs[attrKey];\n        if (val == null) return;\n        expectedAttributeValueCounts[attrKey] = expectedAttributeValueCounts[attrKey] || {};\n        expectedAttributeValueCounts[attrKey][String(val)] = (expectedAttributeValueCounts[attrKey][String(val)] || 0) + 1;\n      });\n    });\n  });\n\n  expect(res.status).toHaveBeenCalledWith(200);\n  expect(res.status.mock.calls.length).toBeGreaterThanOrEqual(1);\n  // The json function is returned from status(), so inspect the last call's json\n  const jsonMock = res.status.mock.results[0].value.json || res.json;\n  // Because our status mock returns an object with json, the json function will be the one captured earlier\n  // Instead of trying to reach into mock internals, just check that res.status was called and that res.status().json was called via the mock implementation.\n\n  // Validate the payload by calling the handler and ensuring the json mock was invoked with expected payload.\n  // The json function was created in createMockRes and is available as res.status().json when status() is called.\n  // Because status was mocked to return { json }, we can access it via res.status.mock.results[0].value.json\n  const calledJson = res.status.mock.results[0].value.json;\n  expect(calledJson).toHaveBeenCalled();\n\n  const payload = calledJson.mock.calls[0][0];\n\n  expect(payload).toMatchObject({\n    totalProducts: expectedTotalProducts,\n    totalVariants: expectedTotalVariants,\n    productsWithVariants: expectedProductsWithVariants,\n    variantsByProduct: expectedVariantsByProduct,\n    attributeValueCounts: expectedAttributeValueCounts,\n  });\n});\n"
    }
  ]
}