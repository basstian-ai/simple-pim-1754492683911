{
  "files": [
    {
      "path": "pages/api/attribute-groups.js",
      "content": "// Simple in-memory Attribute Groups API for the PIM\n// Provides GET (list) and POST (create) endpoints.\n\nconst initialGroups = [\n  {\n    id: 1,\n    code: \"basic\",\n    name: \"Basic\",\n    attributes: [\n      { code: \"sku\", name: \"SKU\", type: \"text\" },\n      { code: \"name\", name: \"Name\", type: \"text\" }\n    ]\n  },\n  {\n    id: 2,\n    code: \"pricing\",\n    name: \"Pricing\",\n    attributes: [\n      { code: \"price\", name: \"Price\", type: \"number\" }\n    ]\n  }\n];\n\nlet store = {\n  groups: initialGroups.map(g => ({ ...g })),\n  nextId: initialGroups.length + 1\n};\n\nfunction getStore() {\n  return store;\n}\n\nfunction resetStore() {\n  store = {\n    groups: initialGroups.map(g => ({ ...g, attributes: g.attributes.map(a => ({ ...a })) })),\n    nextId: initialGroups.length + 1\n  };\n}\n\nfunction parseBody(req) {\n  return new Promise((resolve) => {\n    if (req.body) {\n      return resolve(req.body);\n    }\n    let data = \"\";\n    req.on(\"data\", (chunk) => {\n      data += chunk;\n    });\n    req.on(\"end\", () => {\n      try {\n        resolve(data ? JSON.parse(data) : {});\n      } catch (e) {\n        resolve({});\n      }\n    });\n  });\n}\n\nasync function handler(req, res) {\n  // Minimal CORS friendliness (same-origin is default; this just avoids console noise if someone calls from elsewhere)\n  res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n  res.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n  res.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type\");\n\n  if (req.method === \"OPTIONS\") {\n    res.statusCode = 204;\n    res.end();\n    return;\n  }\n\n  if (req.method === \"GET\") {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(store.groups));\n    return;\n  }\n\n  if (req.method === \"POST\") {\n    const body = await parseBody(req);\n    const { code, name, attributes } = body || {};\n\n    if (!code || !name) {\n      res.statusCode = 400;\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({ error: \"Missing required fields: code, name\" }));\n      return;\n    }\n\n    if (store.groups.some((g) => g.code === code)) {\n      res.statusCode = 409;\n      res.setHeader(\"Content-Type\", \"application/json\");\n      res.end(JSON.stringify({ error: \"Attribute group code already exists\" }));\n      return;\n    }\n\n    const sanitizedAttributes = Array.isArray(attributes)\n      ? attributes\n          .filter((a) => a && a.code && a.name)\n          .map((a) => ({ code: String(a.code), name: String(a.name), type: a.type ? String(a.type) : \"text\" }))\n      : [];\n\n    const newGroup = {\n      id: store.nextId++,\n      code: String(code),\n      name: String(name),\n      attributes: sanitizedAttributes\n    };\n\n    store.groups.push(newGroup);\n\n    res.statusCode = 201;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(newGroup));\n    return;\n  }\n\n  res.statusCode = 405;\n  res.setHeader(\"Allow\", \"GET, POST, OPTIONS\");\n  res.setHeader(\"Content-Type\", \"application/json\");\n  res.end(JSON.stringify({ error: \"Method Not Allowed\" }));\n}\n\n// Export in a way that's friendly to both Next.js and Node tests\nmodule.exports = Object.assign(handler, { getStore, resetStore, default: handler });\n"
    },
    {
      "path": "pages/admin/attribute-groups.js",
      "content": "import React from \"react\";\n\nfunction useAttributeGroups() {\n  const [groups, setGroups] = React.useState([]);\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState(null);\n\n  const fetchGroups = React.useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const res = await fetch(\"/api/attribute-groups\");\n      if (!res.ok) throw new Error(\"Failed to load attribute groups\");\n      const data = await res.json();\n      setGroups(data);\n    } catch (e) {\n      setError(e.message || String(e));\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    fetchGroups();\n  }, [fetchGroups]);\n\n  return { groups, loading, error, refresh: fetchGroups };\n}\n\nexport default function AttributeGroupsAdminPage() {\n  const { groups, loading, error, refresh } = useAttributeGroups();\n  const [code, setCode] = React.useState(\"\");\n  const [name, setName] = React.useState(\"\");\n  const [submitting, setSubmitting] = React.useState(false);\n  const [formError, setFormError] = React.useState(null);\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    setFormError(null);\n    if (!code.trim() || !name.trim()) {\n      setFormError(\"Code and Name are required\");\n      return;\n    }\n    try {\n      setSubmitting(true);\n      const res = await fetch(\"/api/attribute-groups\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ code: code.trim(), name: name.trim(), attributes: [] })\n      });\n      if (!res.ok) {\n        const data = await res.json().catch(() => ({}));\n        throw new Error(data && data.error ? data.error : `Request failed (${res.status})`);\n      }\n      setCode(\"\");\n      setName(\"\");\n      await refresh();\n    } catch (e) {\n      setFormError(e.message || String(e));\n    } finally {\n      setSubmitting(false);\n    }\n  }\n\n  return (\n    <div style={{ maxWidth: 900, margin: \"20px auto\", padding: 16, fontFamily: \"system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif\" }}>\n      <h1 style={{ marginBottom: 8 }}>Attribute Groups</h1>\n      <p style={{ color: \"#555\", marginTop: 0 }}>Create simple attribute groups to organize your product attributes.</p>\n\n      <section style={{ border: \"1px solid #eee\", borderRadius: 8, padding: 16, marginBottom: 24 }}>\n        <h2 style={{ marginTop: 0, fontSize: 18 }}>Add New Group</h2>\n        <form onSubmit={handleSubmit} style={{ display: \"flex\", gap: 8, flexWrap: \"wrap\", alignItems: \"flex-end\" }}>\n          <label style={{ display: \"flex\", flexDirection: \"column\" }}>\n            <span style={{ fontSize: 12, color: \"#666\" }}>Code</span>\n            <input\n              value={code}\n              onChange={(e) => setCode(e.target.value)}\n              placeholder=\"e.g. specs\"\n              style={{ padding: 8, border: \"1px solid #ccc\", borderRadius: 4, minWidth: 180 }}\n            />\n          </label>\n          <label style={{ display: \"flex\", flexDirection: \"column\" }}>\n            <span style={{ fontSize: 12, color: \"#666\" }}>Name</span>\n            <input\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder=\"e.g. Specifications\"\n              style={{ padding: 8, border: \"1px solid #ccc\", borderRadius: 4, minWidth: 220 }}\n            />\n          </label>\n          <button\n            type=\"submit\"\n            disabled={submitting}\n            style={{ padding: \"10px 12px\", borderRadius: 4, border: \"1px solid #333\", background: \"#111\", color: \"#fff\", cursor: \"pointer\" }}\n          >\n            {submitting ? \"Adding...\" : \"Add Group\"}\n          </button>\n        </form>\n        {formError ? <div style={{ color: \"#b00\", marginTop: 8 }}>{formError}</div> : null}\n      </section>\n\n      <section>\n        <h2 style={{ marginTop: 0, fontSize: 18 }}>Existing Groups</h2>\n        {loading && <div>Loading groups...</div>}\n        {error && <div style={{ color: \"#b00\" }}>{error}</div>}\n        {!loading && !error && groups.length === 0 && <div>No attribute groups yet.</div>}\n        <div style={{ display: \"grid\", gap: 12 }}>\n          {groups.map((g) => (\n            <div key={g.id} style={{ border: \"1px solid #eee\", borderRadius: 8, padding: 12 }}>\n              <div style={{ display: \"flex\", alignItems: \"baseline\", gap: 8 }}>\n                <strong>{g.name}</strong>\n                <code style={{ color: \"#666\" }}>{g.code}</code>\n              </div>\n              <div style={{ marginTop: 6, fontSize: 14, color: \"#555\" }}>\n                {g.attributes && g.attributes.length > 0 ? (\n                  <ul style={{ margin: 0, paddingLeft: 18 }}>\n                    {g.attributes.map((a) => (\n                      <li key={`${g.id}:${a.code}`}>\n                        <span>{a.name}</span>\n                        <span style={{ color: \"#888\" }}> ({a.code})</span>\n                        <span style={{ color: \"#aaa\" }}> Â· {a.type}</span>\n                      </li>\n                    ))}\n                  </ul>\n                ) : (\n                  <em style={{ color: \"#777\" }}>No attributes yet</em>\n                )}\n              </div>\n            </div>\n          ))}\n        </div>\n      </section>\n    </div>\n  );\n}\n"
    },
    {
      "path": "__tests__/attribute-groups.test.js",
      "content": "const api = require(\"../pages/api/attribute-groups\");\nconst assert = require(\"assert\");\n\nfunction runApi(method, body) {\n  return new Promise((resolve) => {\n    const req = {\n      method,\n      headers: { \"content-type\": \"application/json\" },\n      body,\n      on: () => {}, // for parseBody fallback\n    };\n\n    const res = {\n      statusCode: 200,\n      headers: {},\n      setHeader(key, val) {\n        this.headers[key.toLowerCase()] = val;\n      },\n      end(payload) {\n        let data = payload;\n        try { data = JSON.parse(payload); } catch {}\n        resolve({ status: this.statusCode, data });\n      }\n    };\n\n    // Mirror res.status(...).json(...) semantics\n    res.status = function (code) { this.statusCode = code; return this; };\n    res.json = function (obj) { this.setHeader(\"content-type\", \"application/json\"); this.end(JSON.stringify(obj)); };\n\n    Promise.resolve(api(req, res)).catch((e) => {\n      res.statusCode = 500;\n      res.end(JSON.stringify({ error: e && e.message ? e.message : String(e) }));\n    });\n  });\n}\n\n(async function main() {\n  // Reset store to a known state\n  if (typeof api.resetStore === \"function\") api.resetStore();\n\n  // GET should return initial groups\n  const r1 = await runApi(\"GET\");\n  assert.strictEqual(r1.status, 200, \"GET should be 200\");\n  assert.ok(Array.isArray(r1.data), \"GET should return an array\");\n  assert.ok(r1.data.length >= 2, \"Should have seeded groups\");\n\n  // POST should create a new group\n  const code = \"specs\";\n  const name = \"Specifications\";\n  const r2 = await runApi(\"POST\", { code, name, attributes: [{ code: \"weight\", name: \"Weight\", type: \"text\" }] });\n  assert.strictEqual(r2.status, 201, \"POST should be 201\");\n  assert.strictEqual(r2.data.code, code, \"Created group should echo code\");\n  assert.strictEqual(r2.data.name, name, \"Created group should echo name\");\n  assert.ok(r2.data.id, \"Created group should have id\");\n\n  // GET again should include new group\n  const r3 = await runApi(\"GET\");\n  assert.ok(r3.data.some((g) => g.code === code), \"List should include created group\");\n\n  // Duplicate code should 409\n  const r4 = await runApi(\"POST\", { code, name: \"Dup\" });\n  assert.strictEqual(r4.status, 409, \"Duplicate code should be conflict\");\n\n  // Missing fields should 400\n  const r5 = await runApi(\"POST\", { name: \"No Code\" });\n  assert.strictEqual(r5.status, 400, \"Missing fields should be bad request\");\n\n  // eslint-disable-next-line no-console\n  console.log(\"attribute-groups.test.js passed\");\n})().catch((e) => {\n  // eslint-disable-next-line no-console\n  console.error(e);\n  process.exit(1);\n});\n"
    }
  ]
}