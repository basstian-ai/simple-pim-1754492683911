{
  "files": [
    {
      "path": "pages/api/products/search.js",
      "content": "'use strict';\n\nconst { getProducts } = require('../../../lib/products');\n\nfunction parseBool(v) {\n  if (v === true || v === false) return !!v;\n  if (v == null) return false;\n  const s = String(v).toLowerCase();\n  return s === '1' || s === 'true' || s === 'yes' || s === 'on';\n}\n\nfunction parseTags(input) {\n  if (!input) return [];\n  if (Array.isArray(input)) return input.map(String).map((t) => t.trim()).filter(Boolean);\n  return String(input)\n    .split(',')\n    .map((t) => t.trim())\n    .filter(Boolean);\n}\n\nfunction productInStock(p) {\n  try {\n    if (typeof p.inStock === 'boolean') return p.inStock;\n    if (typeof p.stock === 'number') return p.stock > 0;\n    if (Array.isArray(p.variants)) {\n      for (const v of p.variants) {\n        if (v && (v.inStock === true)) return true;\n        const qty = typeof v?.stock === 'number' ? v.stock : (typeof v?.inventory === 'number' ? v.inventory : 0);\n        if (qty > 0) return true;\n      }\n      return false;\n    }\n  } catch (_) {}\n  return false;\n}\n\nfunction matchesQuery(p, q) {\n  if (!q) return true;\n  const s = String(q).toLowerCase();\n  const fields = [p.name, p.sku, p.slug, p.description];\n  for (const f of fields) {\n    if (typeof f === 'string' && f.toLowerCase().includes(s)) return true;\n  }\n  // also check tags\n  if (Array.isArray(p.tags) && p.tags.some((t) => String(t).toLowerCase().includes(s))) return true;\n  return false;\n}\n\nfunction hasAllTags(p, required) {\n  if (!required.length) return true;\n  const tags = new Set((Array.isArray(p.tags) ? p.tags : []).map((t) => String(t)));\n  for (const t of required) {\n    if (!tags.has(t)) return false;\n  }\n  return true;\n}\n\nmodule.exports = async function handler(req, res) {\n  try {\n    if (req.method !== 'GET') {\n      res.setHeader('Allow', 'GET');\n      return res.status(405).json({ error: 'Method Not Allowed' });\n    }\n\n    const { q, tags, inStock, limit, offset } = req.query || {};\n\n    const wantInStock = parseBool(inStock);\n    const requiredTags = parseTags(tags);\n    const lim = Math.max(0, Math.min(1000, parseInt(limit, 10) || 50));\n    const off = Math.max(0, parseInt(offset, 10) || 0);\n\n    const all = (await getProducts()) || [];\n\n    const filtered = all.filter((p) => {\n      if (!matchesQuery(p, q)) return false;\n      if (wantInStock && !productInStock(p)) return false;\n      if (!hasAllTags(p, requiredTags)) return false;\n      return true;\n    });\n\n    const items = filtered.slice(off, off + lim);\n\n    return res.status(200).json({ count: filtered.length, limit: lim, offset: off, items });\n  } catch (err) {\n    console.error('products/search error', err);\n    return res.status(500).json({ error: 'Search failed' });\n  }\n};\n"
    },
    {
      "path": "tests/api-products-search.test.js",
      "content": "const handler = require('../pages/api/products/search.js');\nconst sampleProducts = require('../lib/sampleProducts');\n\nfunction createMockRes() {\n  const headers = {};\n  let statusCode = 200;\n  let body;\n  const res = {\n    setHeader: (k, v) => { headers[k] = v; },\n    status: (c) => { statusCode = c; return res; },\n    json: (b) => { body = b; return res; },\n  };\n  Object.defineProperty(res, 'headers', { get: () => headers });\n  Object.defineProperty(res, 'statusCode', { get: () => statusCode });\n  Object.defineProperty(res, 'body', { get: () => body });\n  return res;\n}\n\ndescribe('GET /api/products/search', () => {\n  test('returns items matching a name/sku query', async () => {\n    const p = sampleProducts[0];\n    const q = p.name.split(' ')[0];\n\n    const req = { method: 'GET', query: { q } };\n    const res = createMockRes();\n    await handler(req, res);\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toBeDefined();\n    expect(Array.isArray(res.body.items)).toBe(true);\n    expect(res.body.count).toBeGreaterThan(0);\n    // At least one item should contain the query in name/sku/slug\n    const anyMatch = res.body.items.some((it) =>\n      [it.name, it.sku, it.slug].some((f) => typeof f === 'string' && f.toLowerCase().includes(q.toLowerCase()))\n    );\n    expect(anyMatch).toBe(true);\n  });\n\n  test('filters by tags and supports pagination', async () => {\n    const p = sampleProducts.find((sp) => Array.isArray(sp.tags) && sp.tags.length > 0) || sampleProducts[0];\n    const tag = (p.tags && p.tags[0]) || '';\n\n    const req = { method: 'GET', query: { tags: tag, limit: '1', offset: '0' } };\n    const res = createMockRes();\n    await handler(req, res);\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toBeDefined();\n    expect(typeof res.body.count).toBe('number');\n    expect(res.body.limit).toBe(1);\n    expect(res.body.offset).toBe(0);\n    expect(Array.isArray(res.body.items)).toBe(true);\n    expect(res.body.items.length).toBeLessThanOrEqual(1);\n    // All returned items should include the tag (if a tag was provided)\n    if (tag) {\n      for (const it of res.body.items) {\n        expect(Array.isArray(it.tags)).toBe(true);\n        expect(it.tags).toEqual(expect.arrayContaining([tag]));\n      }\n    }\n  });\n\n  test('rejects non-GET methods', async () => {\n    const req = { method: 'POST', body: {} };\n    const res = createMockRes();\n    await handler(req, res);\n    expect(res.statusCode).toBe(405);\n    expect(res.headers.Allow).toBe('GET');\n  });\n});\n"
    },
    {
      "path": "README.md",
      "content": "# Simple PIM\n\nA modern Product Information Management platform that centralizes product data, supports omnichannel distribution, and enables teams to collaborate efficiently.\n\n## Vision\n\nThe long-term goal is a scalable, extensible system comparable to [Bluestone PIM](https://help.bluestonepim.com/1-get-started-with-bluestonepim) and [Akeneo](https://help.akeneo.com/serenity).\n\n## Features\n\n- Dashboard & Admin Interface: Interactive dashboard showing product counts, enrichment status, and recent activity.\n- Product Management: Admin panel with product list, search/filter, and a tabbed product detail editor.\n- Attribute Management: Create and manage attribute groups.\n- Attribute Export: Download a flattened CSV of all attributes across groups at /api/attribute-groups/flat/export.\n- AI-Powered Suggestions: Get AI-based suggestions for product names and attributes.\n- Data Export: Export products and tags to CSV.\n- Product Search API: Filter by query (name/sku/slug), tags, and stock with pagination at /api/products/search.\n- Tagging and Filtering: Advanced filtering options, including by tags and stock status.\n- Shareable URLs: Filters are reflected in the URL for easy sharing.\n- Bulk Tagging Preview: Admin tool at /admin/bulk-tags with API /api/products/tags/bulk-preview to preview adding/removing tags to many SKUs (no persistence).\n\n## Getting Started\n\nTo get a local copy up and running, follow these simple steps.\n\n### Prerequisites\n\n- npm\n  ```sh\n  npm install npm@latest -g\n  ```\n\n### Installation\n\n1. Clone the repo\n   ```sh\n   git clone https://github.com/basstian-ai/simple-pim-1754492683911.git\n   ```\n2. Install NPM packages\n   ```sh\n   npm install\n   ```\n3. Run the development server\n   ```sh\n   npm run dev\n   ```\n4. Open your browser and navigate to http://localhost:3000\n\n## PIM Development Roadmap\n\n### 1. Dashboard & Admin Interface (Immediate Priority)\n- Build an interactive dashboard showing product counts, enrichment status and recent activity.\n- Implement a responsive admin panel with product list, search/filter, and a tabbed product detail editor.\n- Provide inline editing, variant management and attribute grouping.\n- Deliver navigation, breadcrumbs and user-friendly layouts across desktop and mobile.\n\n### 2. Sample Product Data & Examples (Immediate Priority)\n- Create a realistic sample dataset with categories, attributes, variants and media.\n- Use this dataset in documentation, tests and UI examples.\n- Provide scripts to import/export the sample data.\n\n### 3. Core PIM Foundation\n- Design database schema for products, categories, attributes, variants and media with versioning/audit tables.\n- Expose CRUD APIs for all core entities (REST and GraphQL).\n- Include basic unit tests for APIs and core services.\n\n### 4. Enrichment & Workflow\n- Implement enrichment dashboard showing completeness per channel/locale.\n- Support bulk editing and validation rules for required attributes.\n- Add localization with translation service integration.\n- Provide workflow states (draft → review → approved → published) with transition rules.\n\n### 5. Import/Export & Integration\n- Create CSV/Excel import pipeline with mapping and error reporting.\n- Build connector framework for channel exports (eCommerce platforms, marketplaces, print).\n- Deliver event-driven updates via webhooks.\n- Harden public APIs for third‑party consumption.\n\n### 6. Advanced Capabilities\n- Add DAM module for managing and transforming assets.\n- Support product relationships (bundles, accessories, replacements).\n- Introduce AI‑assisted enrichment such as automatic descriptions and categorization.\n- Enhance search with facets, synonyms and suggestions.\n\n### 7. Governance & Scale\n- Implement RBAC with fine‑grained permissions and SSO support.\n- Provide audit logging for user actions and API calls.\n- Add monitoring, backups and horizontal scaling strategy.\n\n## Success Metrics\n- Data completeness and validation error rates.\n- Time‑to‑market for new products.\n- Adoption of channels/locales and workflow efficiency.\n\n\n## License\n\nDistributed under the MIT License. See LICENSE for more information.\n"
    }
  ]
}