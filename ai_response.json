{
  "files": [
    {
      "path": "lib/attributes-core.js",
      "content": "/* Pure attribute/group helpers for PIM (no browser APIs) */\n\nconst ALLOWED_TYPES = [\"text\", \"number\", \"boolean\", \"select\"];\n\nfunction normalizeCode(input) {\n  const base = (input || \"\").toString().trim().toLowerCase();\n  if (!base) return \"\";\n  return base\n    .replace(/[^a-z0-9_]+/g, \"_\")\n    .replace(/^_+|_+$/g, \"\")\n    .substring(0, 60);\n}\n\nfunction uniqueStrings(arr) {\n  const out = [];\n  const seen = new Set();\n  for (const v of arr) {\n    const s = (v || \"\").toString().trim();\n    if (!s) continue;\n    const key = s.toLowerCase();\n    if (!seen.has(key)) {\n      seen.add(key);\n      out.push(s);\n    }\n  }\n  return out;\n}\n\nfunction normalizeAttribute(attr) {\n  const a = attr || {};\n  const label = (a.label || a.name || a.code || \"\").toString().trim();\n  const code = normalizeCode(a.code || a.name || label);\n  let type = ((a.type || \"text\") + \"\").toLowerCase().trim();\n  if (!ALLOWED_TYPES.includes(type)) type = \"text\";\n  let options = [];\n  if (type === \"select\") {\n    if (Array.isArray(a.options)) {\n      options = uniqueStrings(a.options);\n    } else if (typeof a.options === \"string\") {\n      options = uniqueStrings(a.options.split(/\\r?\\n|,/g));\n    } else {\n      options = [];\n    }\n  }\n  return {\n    id: a.id || null,\n    code,\n    label: label || code,\n    type,\n    required: !!a.required,\n    options,\n  };\n}\n\nfunction validateGroup(group) {\n  const g = group || {};\n  const errors = [];\n  const name = (g.name || \"\").toString().trim();\n  if (!name) errors.push(\"Group name is required\");\n  const attrs = Array.isArray(g.attributes) ? g.attributes : [];\n  const codes = new Set();\n  for (let i = 0; i < attrs.length; i++) {\n    const raw = attrs[i] || {};\n    const a = normalizeAttribute(raw);\n    if (!a.code) errors.push(`Attribute #${i + 1}: code is required`);\n    if (!ALLOWED_TYPES.includes(a.type)) errors.push(`Attribute ${a.code || \"#\" + (i + 1)}: invalid type '${a.type}'`);\n    if (a.type === \"select\") {\n      if (!Array.isArray(a.options) || a.options.length === 0) {\n        errors.push(`Attribute ${a.code || \"#\" + (i + 1)}: at least one option required for 'select' type`);\n      }\n    }\n    const key = a.code;\n    if (key) {\n      if (codes.has(key)) {\n        errors.push(`Duplicate attribute code '${key}' in group`);\n      } else {\n        codes.add(key);\n      }\n    }\n  }\n  return { valid: errors.length === 0, errors };\n}\n\nmodule.exports = { normalizeAttribute, validateGroup, ALLOWED_TYPES };\n"
    },
    {
      "path": "lib/attributes-store.js",
      "content": "export const STORAGE_KEY = 'pim_attribute_groups';\n\nexport function readGroups() {\n  if (typeof window === 'undefined') return [];\n  try {\n    const raw = window.localStorage.getItem(STORAGE_KEY);\n    if (!raw) return [];\n    const data = JSON.parse(raw);\n    if (Array.isArray(data)) return data;\n    return [];\n  } catch (e) {\n    console.warn('Failed to read attribute groups from storage', e);\n    return [];\n  }\n}\n\nexport function writeGroups(groups) {\n  if (typeof window === 'undefined') return;\n  try {\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(groups || []));\n  } catch (e) {\n    console.warn('Failed to write attribute groups to storage', e);\n  }\n}\n"
    },
    {
      "path": "pages/admin/attributes.js",
      "content": "import React, { useEffect, useMemo, useState } from 'react';\nimport { readGroups, writeGroups } from '../../lib/attributes-store';\n\nconst { normalizeAttribute, validateGroup, ALLOWED_TYPES } = require('../../lib/attributes-core');\n\nfunction genId(prefix = 'id') {\n  return `${prefix}_${Math.random().toString(36).slice(2, 8)}_${Date.now().toString(36).slice(-4)}`;\n}\n\nexport default function AttributesAdmin() {\n  const [groups, setGroups] = useState([]);\n  const [loaded, setLoaded] = useState(false);\n  const [newGroup, setNewGroup] = useState({ name: '', description: '' });\n  const [expanded, setExpanded] = useState({});\n  const [newAttrMap, setNewAttrMap] = useState({});\n\n  useEffect(() => {\n    // client-only load\n    const initial = readGroups();\n    setGroups(initial);\n    setLoaded(true);\n  }, []);\n\n  useEffect(() => {\n    if (loaded) writeGroups(groups);\n  }, [groups, loaded]);\n\n  const validations = useMemo(() => {\n    const map = {};\n    for (const g of groups) {\n      map[g.id] = validateGroup(g);\n    }\n    return map;\n  }, [groups]);\n\n  function toggleExpand(groupId) {\n    setExpanded((prev) => ({ ...prev, [groupId]: !prev[groupId] }));\n  }\n\n  function handleAddGroup() {\n    const name = (newGroup.name || '').trim();\n    if (!name) {\n      alert('Please provide a group name');\n      return;\n    }\n    const group = {\n      id: genId('grp'),\n      name,\n      description: (newGroup.description || '').trim(),\n      attributes: [],\n    };\n    setGroups((prev) => [...prev, group]);\n    setNewGroup({ name: '', description: '' });\n    setExpanded((prev) => ({ ...prev, [group.id]: true }));\n  }\n\n  function updateGroupField(groupId, field, value) {\n    setGroups((prev) => prev.map((g) => (g.id === groupId ? { ...g, [field]: value } : g)));\n  }\n\n  function deleteGroup(groupId) {\n    if (!confirm('Delete this group and all its attributes?')) return;\n    setGroups((prev) => prev.filter((g) => g.id !== groupId));\n  }\n\n  function getNewAttr(groupId) {\n    return (\n      newAttrMap[groupId] || {\n        code: '',\n        label: '',\n        type: 'text',\n        required: false,\n        optionsText: '',\n      }\n    );\n  }\n\n  function setNewAttr(groupId, patch) {\n    setNewAttrMap((prev) => ({ ...prev, [groupId]: { ...getNewAttr(groupId), ...patch } }));\n  }\n\n  function handleAddAttribute(groupId) {\n    const form = getNewAttr(groupId);\n    const normalized = normalizeAttribute({\n      code: form.code,\n      label: form.label,\n      type: form.type,\n      required: !!form.required,\n      options: form.optionsText,\n    });\n    if (!normalized.code) {\n      alert('Attribute code is required');\n      return;\n    }\n    if (normalized.type === 'select' && (!normalized.options || normalized.options.length === 0)) {\n      alert(\"Please provide at least one option (comma or newline separated)\");\n      return;\n    }\n    const attr = { ...normalized, id: genId('att') };\n    setGroups((prev) =>\n      prev.map((g) => (g.id === groupId ? { ...g, attributes: [...g.attributes, attr] } : g))\n    );\n    // clear form, keep type/required for faster entry\n    setNewAttr(groupId, { code: '', label: '', optionsText: '' });\n  }\n\n  function deleteAttribute(groupId, attrId) {\n    setGroups((prev) =>\n      prev.map((g) =>\n        g.id === groupId ? { ...g, attributes: g.attributes.filter((a) => a.id !== attrId) } : g\n      )\n    );\n  }\n\n  function exportJson() {\n    const data = JSON.stringify(groups, null, 2);\n    const blob = new Blob([data], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'attribute-groups.json';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    URL.revokeObjectURL(url);\n  }\n\n  function handleImport(e) {\n    const file = e.target.files && e.target.files[0];\n    if (!file) return;\n    const reader = new FileReader();\n    reader.onload = () => {\n      try {\n        const data = JSON.parse(reader.result);\n        if (!Array.isArray(data)) throw new Error('Invalid format');\n        // ensure ids\n        const sanitized = data.map((g) => ({\n          id: g.id || genId('grp'),\n          name: (g.name || '').toString(),\n          description: (g.description || '').toString(),\n          attributes: Array.isArray(g.attributes)\n            ? g.attributes.map((a) => ({ ...normalizeAttribute(a), id: a.id || genId('att') }))\n            : [],\n        }));\n        setGroups(sanitized);\n        e.target.value = '';\n      } catch (err) {\n        alert('Failed to import: ' + err.message);\n      }\n    };\n    reader.readAsText(file);\n  }\n\n  return (\n    <div style={{ maxWidth: 940, margin: '24px auto', padding: '0 16px', fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial' }}>\n      <h1 style={{ marginBottom: 8 }}>Attribute Groups</h1>\n      <p style={{ color: '#555', marginTop: 0 }}>\n        Define attribute groups and basic attributes (text, number, boolean, select). Data is saved to your browser localStorage.\n      </p>\n\n      <section style={{ border: '1px solid #eee', padding: 12, borderRadius: 8, marginBottom: 20 }}>\n        <h3 style={{ marginTop: 0 }}>Create new group</h3>\n        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>\n          <input\n            value={newGroup.name}\n            onChange={(e) => setNewGroup((s) => ({ ...s, name: e.target.value }))}\n            placeholder=\"Group name\"\n            style={{ flex: '1 1 240px', padding: 8 }}\n          />\n          <input\n            value={newGroup.description}\n            onChange={(e) => setNewGroup((s) => ({ ...s, description: e.target.value }))}\n            placeholder=\"Description (optional)\"\n            style={{ flex: '2 1 340px', padding: 8 }}\n          />\n          <button onClick={handleAddGroup} style={{ padding: '8px 12px' }}>Add group</button>\n          <span style={{ flex: 1 }} />\n          <button onClick={exportJson} style={{ padding: '8px 12px' }}>Export JSON</button>\n          <label style={{ display: 'inline-block', padding: '8px 12px', border: '1px solid #ccc', borderRadius: 4, cursor: 'pointer' }}>\n            Import JSON\n            <input type=\"file\" accept=\"application/json\" onChange={handleImport} style={{ display: 'none' }} />\n          </label>\n        </div>\n      </section>\n\n      {groups.length === 0 ? (\n        <div style={{ color: '#666' }}>No groups yet. Create your first group above.</div>\n      ) : (\n        groups.map((g) => {\n          const v = validations[g.id] || { valid: true, errors: [] };\n          const isOpen = !!expanded[g.id];\n          return (\n            <div key={g.id} style={{ border: '1px solid #ddd', borderRadius: 8, marginBottom: 16, overflow: 'hidden' }}>\n              <div style={{ display: 'flex', alignItems: 'center', gap: 8, background: '#fafafa', padding: 10, borderBottom: '1px solid #eee' }}>\n                <button onClick={() => toggleExpand(g.id)} style={{ padding: '6px 10px' }}>{isOpen ? '▾' : '▸'}</button>\n                <input\n                  value={g.name}\n                  onChange={(e) => updateGroupField(g.id, 'name', e.target.value)}\n                  style={{ flex: '1 1 auto', padding: 6, fontWeight: 600 }}\n                />\n                <input\n                  value={g.description || ''}\n                  placeholder=\"Description\"\n                  onChange={(e) => updateGroupField(g.id, 'description', e.target.value)}\n                  style={{ flex: '2 1 auto', padding: 6 }}\n                />\n                <button onClick={() => deleteGroup(g.id)} style={{ padding: '6px 10px', color: '#a00', borderColor: '#e5caca' }}>Delete</button>\n              </div>\n              {!v.valid && (\n                <div style={{ color: '#a00', background: '#fff6f6', padding: '8px 12px', borderBottom: '1px solid #f0dcdc' }}>\n                  {v.errors.join(' • ')}\n                </div>\n              )}\n              {isOpen && (\n                <div style={{ padding: 12 }}>\n                  {g.attributes.length === 0 ? (\n                    <div style={{ color: '#666', marginBottom: 8 }}>No attributes yet.</div>\n                  ) : (\n                    <div style={{ marginBottom: 8 }}>\n                      {g.attributes.map((a) => (\n                        <div key={a.id} style={{ display: 'flex', gap: 8, alignItems: 'center', padding: '6px 0', borderBottom: '1px dashed #eee' }}>\n                          <code style={{ background: '#f6f6f6', padding: '2px 6px', borderRadius: 4 }}>{a.code}</code>\n                          <span style={{ minWidth: 120 }}>{a.label}</span>\n                          <span style={{ color: '#555' }}>{a.type}{a.required ? ' • required' : ''}</span>\n                          {a.type === 'select' && (\n                            <span style={{ color: '#777' }}>options: {Array.isArray(a.options) ? a.options.join(', ') : ''}</span>\n                          )}\n                          <span style={{ flex: 1 }} />\n                          <button onClick={() => deleteAttribute(g.id, a.id)} style={{ padding: '4px 8px', color: '#a00' }}>Remove</button>\n                        </div>\n                      ))}\n                    </div>\n                  )}\n\n                  <div style={{ border: '1px solid #eee', borderRadius: 6, padding: 10 }}>\n                    <strong style={{ display: 'block', marginBottom: 8 }}>Add attribute</strong>\n                    {(() => {\n                      const form = getNewAttr(g.id);\n                      return (\n                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 140px 120px', gap: 8, alignItems: 'start' }}>\n                          <input\n                            value={form.code}\n                            onChange={(e) => setNewAttr(g.id, { code: e.target.value })}\n                            placeholder=\"Code (e.g. color)\"\n                            style={{ padding: 8 }}\n                          />\n                          <input\n                            value={form.label}\n                            onChange={(e) => setNewAttr(g.id, { label: e.target.value })}\n                            placeholder=\"Label (e.g. Color)\"\n                            style={{ padding: 8 }}\n                          />\n                          <select\n                            value={form.type}\n                            onChange={(e) => setNewAttr(g.id, { type: e.target.value })}\n                            style={{ padding: 8 }}\n                          >\n                            {ALLOWED_TYPES.map((t) => (\n                              <option key={t} value={t}>{t}</option>\n                            ))}\n                          </select>\n                          <label style={{ display: 'inline-flex', alignItems: 'center', gap: 6, padding: 8 }}>\n                            <input\n                              type=\"checkbox\"\n                              checked={!!form.required}\n                              onChange={(e) => setNewAttr(g.id, { required: e.target.checked })}\n                            />\n                            required\n                          </label>\n                          {form.type === 'select' && (\n                            <textarea\n                              value={form.optionsText}\n                              onChange={(e) => setNewAttr(g.id, { optionsText: e.target.value })}\n                              placeholder={\"Options (comma or newline separated)\"}\n                              rows={3}\n                              style={{ gridColumn: '1 / span 4', width: '100%', padding: 8 }}\n                            />\n                          )}\n                          <div style={{ gridColumn: '1 / span 4', display: 'flex', justifyContent: 'flex-end' }}>\n                            <button onClick={() => handleAddAttribute(g.id)} style={{ padding: '8px 12px' }}>Add attribute</button>\n                          </div>\n                        </div>\n                      );\n                    })()}\n                  </div>\n                </div>\n              )}\n            </div>\n          );\n        })\n      )}\n\n      <footer style={{ color: '#777', fontSize: 12, marginTop: 24 }}>\n        Tip: Use Export/Import to move definitions between browsers or environments. This is a client-only demo editor.\n      </footer>\n    </div>\n  );\n}\n"
    },
    {
      "path": "tests/attributes.test.js",
      "content": "const assert = require('assert');\nconst { normalizeAttribute, validateGroup } = require('../lib/attributes-core');\n\n// normalizeAttribute\n{\n  const a = normalizeAttribute({ code: ' Color Name ', label: 'Color', type: 'SELECT', options: 'Red, Green, Red\\nBlue' });\n  assert.strictEqual(a.code, 'color_name');\n  assert.strictEqual(a.label, 'Color');\n  assert.strictEqual(a.type, 'select');\n  assert.deepStrictEqual(a.options.sort(), ['Blue', 'Green', 'Red'].sort());\n}\n\n// validateGroup - should catch errors\n{\n  const group = {\n    name: '',\n    attributes: [\n      { code: '', type: 'text' },\n      { code: 'size', type: 'select', options: [] },\n      { code: 'size', type: 'number' },\n    ],\n  };\n  const res = validateGroup(group);\n  assert.strictEqual(res.valid, false);\n  assert(res.errors.some((e) => e.includes('Group name is required')));\n  assert(res.errors.some((e) => e.includes('code is required')));\n  assert(res.errors.some((e) => e.includes(\"at least one option\")));\n  assert(res.errors.some((e) => e.includes('Duplicate attribute code')));\n}\n\n// validateGroup - valid\n{\n  const group = {\n    name: 'Basics',\n    attributes: [\n      { code: 'title', type: 'text', required: true },\n      { code: 'price', type: 'number' },\n      { code: 'published', type: 'boolean' },\n      { code: 'color', type: 'select', options: ['Red', 'Green'] },\n    ],\n  };\n  const res = validateGroup(group);\n  assert.strictEqual(res.valid, true);\n  assert.deepStrictEqual(res.errors, []);\n}\n\nconsole.log('attributes.test.js passed');\n"
    }
  ]
}