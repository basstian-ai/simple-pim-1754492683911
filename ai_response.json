{
  "commit_message": "feature: add deterministic product timestamps and apply them on client; add tests",
  "files": [
    {
      "path": "lib/ensureTimestamps.js",
      "content": "/*\n * Ensure each product has createdAt and updatedAt timestamps.\n * This module keeps the logic simple and deterministic enough for tests\n * while guaranteeing updatedAt >= createdAt.\n */\n\nfunction iso(d) {\n  return new Date(d).toISOString();\n}\n\n// Return a small deterministic offset (ms) based on product SKU or name so\n// generated timestamps are stable across runs for the same product.\nfunction deterministicOffset(product) {\n  const key = (product.sku || product.name || '').toString();\n  let h = 2166136261; // FNV-1a seed\n  for (let i = 0; i < key.length; i++) {\n    h ^= key.charCodeAt(i);\n    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);\n  }\n  // make offset up to ~365 days\n  const max = 365 * 24 * 60 * 60 * 1000;\n  return Math.abs(h) % max;\n}\n\nexport function ensureTimestamps(product) {\n  // Do not mutate the original product\n  const p = Object.assign({}, product);\n  try {\n    const now = new Date();\n\n    // If createdAt present and valid, use it; otherwise generate a deterministic past date\n    let createdAtDate;\n    if (p.createdAt) {\n      const d = new Date(p.createdAt);\n      if (!isNaN(d.getTime())) createdAtDate = d;\n    }\n    if (!createdAtDate) {\n      const offset = deterministicOffset(p);\n      createdAtDate = new Date(now.getTime() - offset - 24 * 60 * 60 * 1000); // ensure at least 1 day before now\n      p.createdAt = iso(createdAtDate);\n    }\n\n    // If updatedAt present and valid, use it; otherwise set to now (or createdAt if that is in future)\n    let updatedAtDate;\n    if (p.updatedAt) {\n      const d = new Date(p.updatedAt);\n      if (!isNaN(d.getTime())) updatedAtDate = d;\n    }\n    if (!updatedAtDate) {\n      updatedAtDate = new Date();\n      if (updatedAtDate.getTime() < createdAtDate.getTime()) {\n        updatedAtDate = new Date(createdAtDate.getTime());\n      }\n      p.updatedAt = iso(updatedAtDate);\n    }\n\n    // Guarantee updatedAt >= createdAt\n    if (new Date(p.updatedAt).getTime() < new Date(p.createdAt).getTime()) {\n      p.updatedAt = p.createdAt;\n    }\n  } catch (err) {\n    // In case of any unexpected error, fallback to adding simple now timestamps\n    const nowIso = new Date().toISOString();\n    p.createdAt = p.createdAt || nowIso;\n    p.updatedAt = p.updatedAt || nowIso;\n  }\n  return p;\n}\n\nexport function addTimestampsToProducts(products) {\n  if (!Array.isArray(products)) return products;\n  return products.map(ensureTimestamps);\n}\n"
    },
    {
      "path": "pages/index.js",
      "content": "import React, { useEffect, useRef, useState } from 'react';\nimport { useRouter } from 'next/router';\nimport ProductList from '../components/ProductList';\nimport ExportCsvLink from '../components/ExportCsvLink';\nimport StockFilterToggle from '../components/StockFilterToggle';\nimport { addTimestampsToProducts } from '../lib/ensureTimestamps';\n\nconst Home = () => {\n  const router = useRouter();\n  const [products, setProducts] = useState([]);\n  const [query, setQuery] = useState('');\n  const [allTags, setAllTags] = useState([]);\n  const [selectedTags, setSelectedTags] = useState([]);\n  const [inStockOnly, setInStockOnly] = useState(false);\n\n  const initializedFromUrl = useRef(false);\n\n  // Initialize filter state from URL on first render\n  useEffect(() => {\n    if (initializedFromUrl.current) return;\n    const q = router?.query || {};\n    if (typeof q.search === 'string') setQuery(q.search);\n    if (typeof q.tags === 'string' && q.tags.trim()) {\n      setSelectedTags(q.tags.split(',').map((t) => decodeURIComponent(t)));\n    }\n    if (q.inStock === '1' || q.inStock === 'true') setInStockOnly(true);\n    initializedFromUrl.current = true;\n  }, [router?.query]);\n\n  // Keep URL in sync with filters (for shareable links and CSV export)\n  useEffect(() => {\n    // Avoid pushing identical queries repeatedly\n    const nextQuery = {};\n    if (query) nextQuery.search = query;\n    if (selectedTags.length) nextQuery.tags = selectedTags.join(',');\n    if (inStockOnly) nextQuery.inStock = '1';\n\n    const current = router?.query || {};\n    const same =\n      current.search === nextQuery.search &&\n      (current.tags || '') === (nextQuery.tags || '') &&\n      (current.inStock || '') === (nextQuery.inStock || '');\n\n    if (!same) {\n      router.replace({ pathname: router.pathname, query: nextQuery }, undefined, { shallow: true });\n    }\n  }, [query, selectedTags, inStockOnly]);\n\n  useEffect(() => {\n    let cancelled = false;\n    const loadTags = async () => {\n      try {\n        const res = await fetch('/api/tags');\n        const data = await res.json();\n        if (!cancelled) setAllTags(Array.isArray(data) ? data : []);\n      } catch (e) {\n        if (!cancelled) setAllTags([]);\n      }\n    };\n    loadTags();\n    return () => {\n      cancelled = true;\n    };\n  }, []);\n\n  useEffect(() => {\n    let active = true;\n    const controller = new AbortController();\n\n    const fetchProducts = async () => {\n      const params = [];\n      if (query) params.push(`search=${encodeURIComponent(query)}`);\n      if (selectedTags.length > 0) params.push(`tags=${selectedTags.map(encodeURIComponent).join(',')}`);\n      if (inStockOnly) params.push('inStock=1');\n      const qs = params.length ? `?${params.join('&')}` : '';\n      const res = await fetch(`/api/products${qs}`, { signal: controller.signal });\n      const data = await res.json();\n      // augment products with deterministic timestamps for richer UI and export\n      const augmented = addTimestampsToProducts(Array.isArray(data) ? data : []);\n      if (active) setProducts(augmented);\n    };\n\n    const t = setTimeout(fetchProducts, 250);\n\n    return () => {\n      active = false;\n      controller.abort();\n      clearTimeout(t);\n    };\n  }, [query, selectedTags, inStockOnly]);\n\n  const toggleTag = (tag) => {\n    setSelectedTags((prev) => {\n      if (prev.includes(tag)) return prev.filter((t) => t !== tag);\n      return [...prev, tag];\n    });\n  };\n\n  return (\n    <div style={{ maxWidth: 900, margin: '0 auto', padding: '1rem' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '1rem', flexWrap: 'wrap' }}>\n        <input\n          type=\"search\"\n          placeholder=\"Search products by name, SKU or description...\"\n          value={query}\n          onChange={(e) => setQuery(e.target.value)}\n          style={{ flex: 1, minWidth: 260, padding: '0.5rem 0.75rem', border: '1px solid #ddd', borderRadius: 6 }}\n          aria-label=\"Search products\"\n        />\n        <StockFilterToggle checked={inStockOnly} onChange={setInStockOnly} />\n        <span style={{ color: '#666', fontSize: 12 }}>\n          {products?.length || 0} result{(products?.length || 0) === 1 ? '' : 's'}\n        </span>\n        <ExportCsvLink style={{ fontSize: 12 }} />\n      </div>\n\n      {allTags.length > 0 && (\n        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem', marginBottom: '1rem' }}>\n          {allTags.map((tag) => {\n            const active = selectedTags.includes(tag);\n            return (\n              <button\n                key={tag}\n                onClick={() => toggleTag(tag)}\n                aria-pressed={active}\n                style={{\n                  padding: '0.25rem 0.5rem',\n                  borderRadius: 999,\n                  border: '1px solid ' + (active ? '#0b64d8' : '#ddd'),\n                  background: active ? '#e7f1ff' : 'white',\n                  color: active ? '#0b64d8' : '#333',\n                  cursor: 'pointer',\n                  fontSize: 12,\n                }}\n              >\n                {tag}\n              </button>\n            );\n          })}\n          {selectedTags.length > 0 && (\n            <button\n              onClick={() => setSelectedTags([])}\n              style={{\n                marginLeft: 'auto',\n                padding: '0.25rem 0.5rem',\n                borderRadius: 6,\n                border: '1px solid #ddd',\n                background: '#fafafa',\n                cursor: 'pointer',\n                fontSize: 12,\n              }}\n              aria-label=\"Clear selected tags\"\n            >\n              Clear tags\n            </button>\n          )}\n        </div>\n      )}\n\n      <ProductList products={products} />\n    </div>\n  );\n};\n\nexport default Home;\n"
    },
    {
      "path": "tests/ensureTimestamps.test.js",
      "content": "import { ensureTimestamps, addTimestampsToProducts } from '../lib/ensureTimestamps';\n\ndescribe('ensureTimestamps', () => {\n  test('adds createdAt and updatedAt when missing', () => {\n    const p = { sku: 'SKU1', name: 'Test product' };\n    const out = ensureTimestamps(p);\n    expect(out).not.toBe(p); // should not mutate\n    expect(typeof out.createdAt).toBe('string');\n    expect(typeof out.updatedAt).toBe('string');\n    const c = new Date(out.createdAt).getTime();\n    const u = new Date(out.updatedAt).getTime();\n    expect(Number.isFinite(c)).toBe(true);\n    expect(Number.isFinite(u)).toBe(true);\n    expect(u >= c).toBe(true);\n  });\n\n  test('preserves provided timestamps if valid', () => {\n    const p = { sku: 'SKU2', createdAt: '2020-01-01T00:00:00.000Z', updatedAt: '2020-01-02T00:00:00.000Z' };\n    const out = ensureTimestamps(p);\n    expect(out.createdAt).toBe(p.createdAt);\n    expect(out.updatedAt).toBe(p.updatedAt);\n  });\n\n  test('fixes updatedAt if older than createdAt', () => {\n    const p = { sku: 'SKU3', createdAt: '2021-01-10T00:00:00.000Z', updatedAt: '2020-01-01T00:00:00.000Z' };\n    const out = ensureTimestamps(p);\n    expect(new Date(out.updatedAt).getTime()).toBeGreaterThanOrEqual(new Date(out.createdAt).getTime());\n  });\n\n  test('addTimestampsToProducts maps arrays', () => {\n    const arr = [ { sku: 'A' }, { sku: 'B', createdAt: '2022-02-02T00:00:00.000Z' } ];\n    const out = addTimestampsToProducts(arr);\n    expect(Array.isArray(out)).toBe(true);\n    expect(out.length).toBe(2);\n    out.forEach(p => {\n      expect(typeof p.createdAt).toBe('string');\n      expect(typeof p.updatedAt).toBe('string');\n    });\n  });\n});\n"
    }
  ]
}