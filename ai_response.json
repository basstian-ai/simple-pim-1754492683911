{
  "files": [
    {
      "path": "data/attribute-groups.json",
      "content": "[\n  {\n    \"id\": \"general\",\n    \"name\": \"General\",\n    \"description\": \"Common product attributes used across most listings.\",\n    \"attributes\": [\n      { \"code\": \"name\", \"label\": \"Name\", \"type\": \"text\", \"required\": true },\n      { \"code\": \"sku\", \"label\": \"SKU\", \"type\": \"text\", \"required\": true },\n      { \"code\": \"description\", \"label\": \"Description\", \"type\": \"richtext\", \"required\": false },\n      { \"code\": \"price\", \"label\": \"Price\", \"type\": \"number\", \"required\": true },\n      { \"code\": \"currency\", \"label\": \"Currency\", \"type\": \"select\", \"options\": [\"USD\", \"EUR\", \"GBP\"], \"required\": true }\n    ]\n  },\n  {\n    \"id\": \"seo\",\n    \"name\": \"SEO\",\n    \"description\": \"Search engine optimization related fields.\",\n    \"attributes\": [\n      { \"code\": \"meta_title\", \"label\": \"Meta Title\", \"type\": \"text\", \"required\": false },\n      { \"code\": \"meta_description\", \"label\": \"Meta Description\", \"type\": \"textarea\", \"required\": false },\n      { \"code\": \"slug\", \"label\": \"URL Slug\", \"type\": \"text\", \"required\": true }\n    ]\n  }\n]\n"
    },
    {
      "path": "pages/api/attribute-groups.js",
      "content": "import fs from 'fs';\nimport path from 'path';\n\nfunction readAttributeGroups() {\n  const filePath = path.join(process.cwd(), 'data', 'attribute-groups.json');\n  const raw = fs.readFileSync(filePath, 'utf8');\n  return JSON.parse(raw);\n}\n\nexport default function handler(req, res) {\n  if (req.method !== 'GET') {\n    res.setHeader('Allow', 'GET');\n    return res.status(405).json({ error: 'Method Not Allowed' });\n  }\n\n  try {\n    const groups = readAttributeGroups();\n    return res.status(200).json({ groups });\n  } catch (err) {\n    console.error('Failed to load attribute groups:', err);\n    return res.status(500).json({ error: 'Failed to load attribute groups' });\n  }\n}\n"
    },
    {
      "path": "pages/admin/attribute-groups.js",
      "content": "import { useEffect, useMemo, useState } from 'react';\nimport path from 'path';\nimport fs from 'fs';\n\nexport default function AttributeGroupsAdmin({ initialGroups }) {\n  const [groups, setGroups] = useState(initialGroups || []);\n  const [query, setQuery] = useState('');\n  const [expanded, setExpanded] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let mounted = true;\n    async function load() {\n      try {\n        setLoading(true);\n        setError(null);\n        const res = await fetch('/api/attribute-groups');\n        if (!res.ok) throw new Error('Failed to fetch');\n        const data = await res.json();\n        if (mounted && Array.isArray(data.groups)) {\n          setGroups(data.groups);\n        }\n      } catch (e) {\n        if (mounted) setError('Unable to refresh groups');\n      } finally {\n        if (mounted) setLoading(false);\n      }\n    }\n    load();\n    return () => { mounted = false; };\n  }, []);\n\n  const filtered = useMemo(() => {\n    const q = query.trim().toLowerCase();\n    if (!q) return groups;\n    return groups.filter(g => {\n      if (g.name.toLowerCase().includes(q)) return true;\n      if (g.description && g.description.toLowerCase().includes(q)) return true;\n      return (g.attributes || []).some(a => (\n        (a.code && a.code.toLowerCase().includes(q)) ||\n        (a.label && a.label.toLowerCase().includes(q)) ||\n        (a.type && a.type.toLowerCase().includes(q))\n      ));\n    });\n  }, [groups, query]);\n\n  return (\n    <div style={{ maxWidth: 980, margin: '32px auto', padding: '0 16px', fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif' }}>\n      <h1 style={{ marginBottom: 8 }}>Attribute Groups</h1>\n      <p style={{ color: '#555', marginTop: 0 }}>Browse and inspect product attribute groups configured in your PIM.</p>\n\n      <div style={{ display: 'flex', gap: 12, alignItems: 'center', margin: '16px 0 24px' }}>\n        <input\n          type=\"search\"\n          placeholder=\"Search groups or attributes...\"\n          value={query}\n          onChange={(e) => setQuery(e.target.value)}\n          style={{ flex: 1, padding: '10px 12px', borderRadius: 8, border: '1px solid #ddd' }}\n          aria-label=\"Search\"\n        />\n        <button\n          onClick={() => window.location.reload()}\n          style={{ padding: '10px 14px', borderRadius: 8, border: 0, background: '#111', color: 'white', cursor: 'pointer' }}\n          aria-busy={loading}\n        >\n          {loading ? 'Refreshing…' : 'Refresh'}\n        </button>\n      </div>\n      {error && (\n        <div role=\"alert\" style={{ background: '#fff3f3', color: '#a00', padding: '8px 12px', borderRadius: 6, border: '1px solid #f3d6d6', marginBottom: 16 }}>\n          {error}\n        </div>\n      )}\n\n      <div style={{ display: 'grid', gap: 12 }}>\n        {filtered.map(group => (\n          <div key={group.id} style={{ border: '1px solid #eee', borderRadius: 10, overflow: 'hidden', background: 'white' }}>\n            <button\n              onClick={() => setExpanded(prev => ({ ...prev, [group.id]: !prev[group.id] }))}\n              style={{\n                display: 'flex', width: '100%', textAlign: 'left', padding: '14px 16px', gap: 12, alignItems: 'center',\n                border: 0, background: 'white', cursor: 'pointer', fontSize: 16\n              }}\n              aria-expanded={!!expanded[group.id]}\n            >\n              <span style={{ fontWeight: 600 }}>{group.name}</span>\n              <span style={{ color: '#666' }}>• {group.attributes?.length || 0} attributes</span>\n            </button>\n            {group.description ? (\n              <div style={{ padding: '0 16px 12px', color: '#555' }}>{group.description}</div>\n            ) : null}\n            {expanded[group.id] ? (\n              <div style={{ padding: 16, borderTop: '1px solid #f2f2f2' }}>\n                <div style={{ overflowX: 'auto' }}>\n                  <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 14 }}>\n                    <thead>\n                      <tr>\n                        <th style={th}>Code</th>\n                        <th style={th}>Label</th>\n                        <th style={th}>Type</th>\n                        <th style={th}>Required</th>\n                        <th style={th}>Options</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {(group.attributes || []).map(attr => (\n                        <tr key={attr.code}>\n                          <td style={tdMono}>{attr.code}</td>\n                          <td style={td}>{attr.label}</td>\n                          <td style={td}>{attr.type}</td>\n                          <td style={td}>{attr.required ? 'Yes' : 'No'}</td>\n                          <td style={td}>{Array.isArray(attr.options) ? attr.options.join(', ') : '—'}</td>\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              </div>\n            ) : null}\n          </div>\n        ))}\n      </div>\n\n      {filtered.length === 0 && (\n        <div style={{ color: '#666', padding: '24px 4px' }}>No groups match your search.</div>\n      )}\n    </div>\n  );\n}\n\nconst th = { textAlign: 'left', borderBottom: '1px solid #eee', padding: '8px 8px', color: '#666', fontWeight: 600 };\nconst td = { borderBottom: '1px solid #f7f7f7', padding: '8px 8px' };\nconst tdMono = { ...td, fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace' };\n\nexport async function getStaticProps() {\n  // Load initial data at build-time for fast first paint\n  try {\n    const filePath = path.join(process.cwd(), 'data', 'attribute-groups.json');\n    const raw = fs.readFileSync(filePath, 'utf8');\n    const initialGroups = JSON.parse(raw);\n    return { props: { initialGroups } };\n  } catch (e) {\n    return { props: { initialGroups: [] } };\n  }\n}\n"
    },
    {
      "path": "tests/attribute-groups.schema.test.js",
      "content": "/*\n  Minimal schema test for attribute groups data.\n  Run with: node tests/attribute-groups.schema.test.js\n*/\nconst fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\n\nconst filePath = path.join(process.cwd(), 'data', 'attribute-groups.json');\nconst raw = fs.readFileSync(filePath, 'utf8');\nconst groups = JSON.parse(raw);\n\ntry {\n  assert(Array.isArray(groups), 'groups should be an array');\n  for (const g of groups) {\n    assert.strictEqual(typeof g.id, 'string', 'group.id must be string');\n    assert.ok(g.id.length > 0, 'group.id must not be empty');\n    assert.strictEqual(typeof g.name, 'string', 'group.name must be string');\n    assert.ok(Array.isArray(g.attributes), 'group.attributes must be array');\n    for (const a of g.attributes) {\n      assert.strictEqual(typeof a.code, 'string', 'attribute.code must be string');\n      assert.strictEqual(typeof a.label, 'string', 'attribute.label must be string');\n      assert.strictEqual(typeof a.type, 'string', 'attribute.type must be string');\n      if (a.options !== undefined) {\n        assert.ok(Array.isArray(a.options), 'attribute.options must be array when provided');\n      }\n    }\n  }\n  console.log('OK: attribute-groups schema is valid');\n  process.exit(0);\n} catch (err) {\n  console.error('FAIL:', err.message);\n  process.exit(1);\n}\n"
    },
    {
      "path": ".commit_message",
      "content": "feat(attribute-groups): add read-only attribute groups API, admin list view, and minimal schema test\n\n- Introduce data/attribute-groups.json as seed data\n- Add pages/api/attribute-groups for GET access\n- Add pages/admin/attribute-groups UI with search and expandable details\n- Include a simple Node-based schema test for the attribute groups data\n"
    }
  ]
}