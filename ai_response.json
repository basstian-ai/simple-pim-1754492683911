{
  "files": [
    {
      "path": "lib/attributeGroupsSchema.js",
      "content": "const ALLOWED_ATTRIBUTE_TYPES = ['text', 'number', 'boolean', 'select', 'multiselect', 'date'];\n\nfunction isNonEmptyString(v) {\n  return typeof v === 'string' && v.trim().length > 0;\n}\n\nfunction validateAttribute(attr, idx, seenCodes) {\n  const errors = [];\n  if (!attr || typeof attr !== 'object') {\n    errors.push({ path: `attributes[${idx}]`, message: 'Attribute must be an object' });\n    return errors;\n  }\n\n  if (!isNonEmptyString(attr.code)) {\n    errors.push({ path: `attributes[${idx}].code`, message: 'code is required and must be a non-empty string' });\n  } else {\n    const code = attr.code.trim();\n    if (seenCodes.has(code)) {\n      errors.push({ path: `attributes[${idx}].code`, message: `duplicate code within group: ${code}` });\n    } else {\n      seenCodes.add(code);\n    }\n  }\n\n  if (attr.type != null) {\n    if (typeof attr.type !== 'string') {\n      errors.push({ path: `attributes[${idx}].type`, message: 'type must be a string' });\n    } else if (!ALLOWED_ATTRIBUTE_TYPES.includes(attr.type)) {\n      errors.push({ path: `attributes[${idx}].type`, message: `unsupported type '${attr.type}'. Allowed: ${ALLOWED_ATTRIBUTE_TYPES.join(', ')}` });\n    }\n  }\n\n  if (attr.options != null) {\n    if (!Array.isArray(attr.options)) {\n      errors.push({ path: `attributes[${idx}].options`, message: 'options must be an array when provided' });\n    }\n  }\n\n  return errors;\n}\n\nfunction validateGroup(group, index) {\n  const errors = [];\n  if (!group || typeof group !== 'object') {\n    errors.push({ path: `groups[${index}]`, message: 'Group must be an object' });\n    return errors;\n  }\n\n  if (!isNonEmptyString(group.name)) {\n    errors.push({ path: `groups[${index}].name`, message: 'name is required and must be a non-empty string' });\n  }\n\n  if (group.description != null && typeof group.description !== 'string') {\n    errors.push({ path: `groups[${index}].description`, message: 'description must be a string when provided' });\n  }\n\n  const attrs = Array.isArray(group.attributes) ? group.attributes : [];\n  if (!Array.isArray(group.attributes)) {\n    errors.push({ path: `groups[${index}].attributes`, message: 'attributes must be an array' });\n  }\n\n  const seenCodes = new Set();\n  attrs.forEach((attr, i) => {\n    const attrErrors = validateAttribute(attr, i, seenCodes);\n    attrErrors.forEach((e) => errors.push({ path: `groups[${index}].${e.path}`, message: e.message }));\n  });\n\n  return errors;\n}\n\nfunction validateGroups(input) {\n  const result = { valid: true, errors: [], count: 0 };\n  const groups = Array.isArray(input) ? input : (input && Array.isArray(input.groups) ? input.groups : []);\n\n  if (!Array.isArray(groups)) {\n    result.valid = false;\n    result.errors.push({ path: 'groups', message: 'groups must be an array' });\n    return result;\n  }\n\n  result.count = groups.length;\n  groups.forEach((g, i) => {\n    const errs = validateGroup(g, i);\n    result.errors.push(...errs);\n  });\n\n  if (result.errors.length > 0) {\n    result.valid = false;\n  }\n  return result;\n}\n\nmodule.exports = {\n  ALLOWED_ATTRIBUTE_TYPES,\n  validateGroups,\n};\n"
    },
    {
      "path": "pages/api/attribute-groups/validate.js",
      "content": "const { validateGroups } = require('../../../lib/attributeGroupsSchema');\n\nfunction handler(req, res) {\n  if (req.method !== 'POST') {\n    res.setHeader('Allow', 'POST');\n    return res.status(405).json({ error: 'Method Not Allowed' });\n  }\n\n  const payload = req.body;\n  const result = validateGroups(payload);\n  if (!result.valid) {\n    return res.status(400).json(result);\n  }\n  return res.status(200).json(result);\n}\n\nmodule.exports = handler;\n"
    },
    {
      "path": "tests/api-attribute-groups-validate.test.js",
      "content": "const handler = require('../pages/api/attribute-groups/validate.js');\n\nfunction createMockReqRes(method = 'POST', body = null) {\n  const req = { method, body };\n  const res = {\n    _status: 200,\n    _headers: {},\n    _json: undefined,\n    setHeader(k, v) { this._headers[k] = v; },\n    status(code) { this._status = code; return this; },\n    json(obj) { this._json = obj; return this; },\n  };\n  return { req, res };\n}\n\ndescribe('API /api/attribute-groups/validate', () => {\n  test('returns 200 and valid=true for a correct payload', async () => {\n    const good = {\n      groups: [\n        { name: 'General', description: 'Common data', attributes: [ { code: 'color', type: 'text' }, { code: 'size', type: 'select', options: ['S','M','L'] } ] },\n      ],\n    };\n    const { req, res } = createMockReqRes('POST', good);\n    await handler(req, res);\n    expect(res._status).toBe(200);\n    expect(res._json).toBeDefined();\n    expect(res._json.valid).toBe(true);\n    expect(res._json.count).toBe(1);\n  });\n\n  test('returns 400 and errors for invalid payload (missing group name, duplicate attribute code)', async () => {\n    const bad = {\n      groups: [\n        { description: 'no name here', attributes: [ { code: 'a', type: 'text' }, { code: 'a', type: 'text' } ] },\n      ],\n    };\n    const { req, res } = createMockReqRes('POST', bad);\n    await handler(req, res);\n    expect(res._status).toBe(400);\n    expect(res._json).toBeDefined();\n    expect(res._json.valid).toBe(false);\n    expect(Array.isArray(res._json.errors)).toBe(true);\n    expect(res._json.errors.length).toBeGreaterThan(0);\n  });\n\n  test('returns 405 for non-POST', async () => {\n    const { req, res } = createMockReqRes('GET');\n    await handler(req, res);\n    expect(res._status).toBe(405);\n  });\n});\n"
    }
  ]
}